A Few More Reasons to Learn Swift
Reasons to Learn Swift That Don't Include the Word 'Apple'
You have your own reasons for learning Swift, but in the next 2 minutes, let me try and add a few more on top of that. I know 9 out of 10 people watching this course are most interested in this language for what it's known for on Apple platforms, to make apps that run on the iPhone, or the iPad, or on the Mac, or even on the Watch, or the Apple TV. But the options are wider. Swift may have started at Apple, but it became completely open source at the end of 2015. It is already available on other platforms. We have full support for writing Swift on Linux. We can already use Swift for building server-side applications. 

That may not sound like a big deal, but before Swift came along, one challenge when developing in the Apple world is you'd build your iOS and Mac client applications in one language, usually Objective-C, but you'd then have to use a completely different language and technology, like Node or Ruby on Rails, for any part that needed to run on the server. But now there are already multiple web frameworks for Swift, including Vapor, Kitura, Perfect, and Zewo. They're all open source. They all allow us to use Swift from one end of our project to the other. And we're already seeing support for Swift in commercial cloud services, particularly with IBM and their Bluemix platform. Beyond the pragmatic benefit of having more and more places where we'll be able to use Swift, even if right now you weren't focused on any of the practical applications, simply exploring this language can help expand your own programming abilities because there are modern features and techniques built into Swift you just won't find in a language with a 20 or 30-year history, like the patterns Swift adopts from functional programming. And, as we'll see, Swift also brings a shift in focus. There's a slightly different way of thinking here when writing code to solve your problems. And I'll talk about these new features. We will explore how to make that shift. 

But a warning. If you jump into Swift thinking this is going to be just like Java or just like C#, or just like, 
(Woman) insert your favorite language here, only with a few syntax changes, you will mismatch on this language. Taking that approach will work for a little while. A lot of this language feels and is familiar. But if you only grab onto what's familiar, the features here that are exactly the same as something you already know in another language, you'll end up avoiding what makes Swift Swift. 

It's those things that are a little different. Not very different, but a little different, and good different. So, expect this course to be more than just me going over a bunch of rules about syntax. We will do that, and we'll also 
explore current best practices
style guidelines
we will explore the ideas too 

because when you're comfortable with not just what is different in Swift, but why it's different, it makes it so much easier to write this and write it well. But the cliche that you might see on a tech website that Swift is Apple's programming language for making iPhone apps is by no means the full story. It is already broader and deeper than that. Having said all that, if what you want to do is make an iPhone app, well, yeah, it's brilliant at that.

 
The One Thing I Expect (And Two Things You Should)
I don't assume you've done anything with the Swift programming language yet. We are taking this from the very beginning. But okay, we're programmers. Programmers tend to experiment, so I realized some people watching this course will have tried Swift already. Anything from experimenting to a few lines of code. Some of you may have even spent significant time learning Swift when it first came out, just never quite got your Swift skills to where you wanted them, and then perhaps even kind of lost track with what happened with Swift over the last few years. And there are good reasons why that might be true. 
Swift 1
After all, the Swift programming language version 1.0 was only released in late 2014. I'm recording this course in late 2018. We're now onto Swift 4.2, and a lot has happened in the past few years. And if you had learned to write Swift version 1, a great deal of the code you know how to write broke when we went to Swift 2. 
Swift 2
There were major changes and tweaks and refinements in the syntax. If you'd written a lot of Swift 2, a lot of that code broke when we went to Swift 3. Swift has been changeable, and that was frustrating if you were trying to learn the language as all these changes were happening. But that situation is now over. 
Swift 3
When we got to Swift 3 in 2016, the Swift team had a stated goal of what they call source compatibility. Simply put, going forward, we just do not expect the same kind of breaking changes we had up to that point. Swift 3 was a significant maturity point. 
Swift 2
And we're now into Swift 4, specifically Swift 4.2 released late 2018, and although there will be changes in the future, the language is stable. So if you were waiting for a good time to really learn Swift, right now is ideal. Now although there is a full set of tools for writing Swift on Linux, in this course I'm going to be using a Mac, and I'll be using Xcode 10. I'm not going to try and make anybody an expert on Xcode, we'll only need to know the basics here, but Xcode is the most common programming environment for writing Swift, it's definitely the best choice for learning Swift, and it's free. So if you have a Mac running a recent macOS and you've installed Xcode 10 free from the Mac App Store, that's all you need to get started. And there's one thing you should expect from me as we dive in, that I will focus here on the Swift language itself and not on the specifics of iPhone or iPad or Watch or Mac or Apple TV development. Because even if you are really impatient to make, say, an iPhone app, once you start programming that device, it's very easy to get distracted by how do you program the buttons, and how do you work with animation, and the application lifecycle, and how do you swipe, and how do you tilt, and how do you access the volume button, or the camera, or all the libraries, and a thousand other things that will be important later, but have nothing to do with Swift now. 

Now the right way to do this is first spend just a few hours to get comfortable with the language itself. Get it into your bones. Explore its most important ideas. Then you can dive into making any kind of app. So, there's one thing I expect from you, which is this is a Swift fundamentals course. It is not a programming fundamentals course. As I said, I will cover everything about the language, from making constants and variables, conditions and loops, but I do expect you know what those are and you have practical experience in some other programming language. If you are brand new to programming, this is not the place to begin. I suggest you take a look at my What is Programming course here at Pluralsight before coming back. But enough of an introduction. Let's see some Swift.

The Basic Structure of Swift
Imagine I asked you and a few other software developers into a room to take a look at some code. Now this code is written in Swift, but let's say you didn't know that yet. And without saying what language this was, I asked you to tell me about it. 
 

First, someone would say: 

(Man) This looks like a C style language. 


(Woman) We've got blocks of code with curly braces. 


(Man) Comments using two forward slashes. 


(Woman) A lot of keywords in lower case. 


(Man) And C style control structures like if statements and while loops. 


And yes, Swift does use the general style of the C family of languages, so it looks more like C or Java or C# than it does Python or Visual Basic or COBOL. Next, someone would point out: 

(Man) This code includes the word class. 

(Woman) And there are comments for properties and methods. 

(Man) So it's probably an object-oriented language. 


And this is also true. Swift supports object-orientation ideas like classes and objects, methods and properties, and inheritance because while Swift is a new language, it was intentionally designed to be familiar. But familiar does not mean identical. 

There are a few simple obvious differences and many subtle deeper ones. 

Two simple differences. 

First, if this is a C-style language, then where are the semicolons at the end of each statement? And if it is a C-style language, where's the main method or the main function to identify the entry point of this program? So, in Swift, you don't need semicolons at the end of a statement. 

The same way that as programmers we could read this code and easily make a distinction between one line and the next, so can a modern compiler. We don't need semicolons anymore. Now if you're so used to typing semicolons that you unconsciously put one at the end of every statement, it won't cause an error here. Swift will understand. 

But unlike a few languages where you don't need semicolons, but the best practice is write them anyway, here the best practice is don't. You don't need the semicolons in Swift. Don't write the semicolons in Swift. Not needing a semicolon sounds like a tiny thing, but it's an indicator of what you'll see over and over again in Swift, a focus on simplicity, clarity, readability. That in Swift if you can remove a character or a word or a line and not lose any meaning, we will do that. Moving on. Unlike many C-style languages, Swift does not need a main method or a main function. If you write some simple Swift code and run it, by default it just begins at the top and works its way down line by line. So even this would be considered an entire valid Swift program. Print here is a built-in function in Swift, a simple way to output some text to the console. Okay, I get it. It's easy to zone out with this kind of hello world content. You know you're never going to write a one-line program. But this line is not what's important here. What's important here is what you don't need. We don't begin this with a line to import or include or link to some other library because the core Swift functionality just works without any of that. And we don't need to wrap this in a main function or a main method, and we don't need to return a result to the operating system. So a lot of the boilerplate code that's just part of the landscape of other programming languages is not needed here. 

There are places where a piece of Swift syntax might look unfamiliar to you, but is easy enough to figure out. For example, this func keyword. This is a keyword you don't find in many languages, but if you guessed that we might use func to define functions, reusable chunks of code, you would be correct. 


And we will dive into this syntax in just a few minutes. Not everything is as obvious. Even in simple code there's also places where a piece of Swift syntax might look similar to something you already know, but is actually deceptively different. I've got some Swift code using the var keyword. 

Var, or some people will say ver, is not an unusual keyword. If you program JavaScript or Go, you'll know it well. But even if you hadn't, if you made the reasonable assumption that we use var to define variables, you would be correct. However, beyond that, assumptions are dangerous. Notice that I don't explicitly provide a data type for any of these. I seem to be creating something that looks like a string and then an integer value, some kind of floating point value, then what looks like a Boolean, and it would be very easy for a developer to read this code and 







Swift is most definitely a type-safe language. Let me say that again with trumpets for emphasis. (Trumpets sounding) Swift is a type-safe language. It is meticulous about every single piece of data you're going to have in your program and exactly what that data is allowed to be. So there is more going on here than is immediately obvious, and the way to make this obvious is we start writing and running it.

Writing and Running Swift in a Playground
Learning a new programming language takes a certain amount of concentration. It's not unusual to get ourselves motivated, make that initial push into a language, and spend most of our effort not on the language, but on a bunch of other peripheral stuff. Downloading and configuring toolsets and compilers or figuring out which of the 14 different versions of the development environment we're supposed to use. With some technologies, it's almost impossible to write a line of code without first learning about making projects or workspaces and the organizational paradigm of how your project should be named and where they should be saved and what folders and subfolders and configuration files you will suddenly have. But with Swift, we can just get into the language quickly if that's what we want to do. True, there is one requirement, Xcode. For most people, that's a few clicks. Go to the Mac App Store, go to the Apps for Developers section, or just search for Xcode. Click to install. That's it. You're done. Okay, first you wait while it downloads and installs. It's a big download, several gigabytes, because Xcode includes everything you need not just for learning Swift, but also for making iPhone apps, making Mac apps, Watch apps, TV apps, games, code editing, designing user interfaces, debugging, testing. It is a classic IDE, or integrated development environment. Now, like most other IDEs, when you start using Xcode to make apps, like an iOS app or a Mac app or a game, it has ways it can help us create and group and manage all the different files and assets we'll need for that kind of app into what Xcode calls a project. But we don't need to worry about projects just yet. Because when you just want to write and run some Swift, when you're learning a new piece of syntax, you're experimenting, you want to test an idea, we can create a playground, not a project. Opening Xcode, the first option on the Welcome screen isn't the way to make a project; it's a way to make a playground. Now if you've dismissed this screen, you can also use File, New, Playground. And we're first asked to choose whether this playground is for iOS, tvOS, or macOS development. Right now, for what we're doing here, this choice doesn't matter, but I do have to pick one, so I'll pick iOS. Below that, select the simplest option of a blank playground. Click Next. I'll give this playground a name, call it FirstPlayground, and save it to my Desktop, and it will be saved as a single file. And you can save playgrounds anywhere. There is no special location that they must be stored in. So a playground is a specific file type. It appears as a simple, single, standalone file for us to write Swift. But not just to write it. Playgrounds also let us test, interact, and view the results of our Swift code as we're writing it line by line. Now a moment ago I selected the iOS option, and by doing that, Xcode automatically added this import statement to the playground. If I'd chosen macOS or tvOS, I'd have a slightly different import statement here. 


But wait, Simon, you say. In the previous clip, you said we didn't need an import statement with Swift. And that's true. We don't need that line. It's been added in case I wanted to write some Swift that would work with iOS objects, say user interface elements like buttons or sliders. But we're not doing that right now, so we don't need this line or any of the others. We can just begin from a blank slate. So we use the keyword var to declare a variable in Swift, followed by the name we want to call that variable. In Swift, as in many languages, the naming convention for variables is CamelCase. We start with a lowercase first letter, but capitalize any subsequent word. 


Now this code by itself is not valid, it's not complete yet, and Xcode automatically attempts to parse this playground code as we're writing it, and I'll see an error message pop up on the right, this rather cryptic sounding Type annotation missing in pattern. Now we'll get into this in a moment, but to finish this line, I will provide an initial value for this variable. The error now goes away. This is a valid line of Swift. I'll create a few more variables using the same format, but setting these variables to different kinds of values, different types of data. 
 
If we think back to our imaginary group of developers, if I'd asked them to describe these values, what kinds of data are we working with here, they would say something like: 
(Man) The first one certainly looks like a string value. 
(Woman) The second is an integer. 
(Man) The third is some kind of floating point value. 
(Woman) And this last one is a Boolean. Right now the Swift compiler is doing exactly the same thing because when we declare variables and provide these initial values for them, Swift looks at the values and figures out or infers what the data type is here, what is called type inference. This value, Alice inside double quotes, is inferred as a string, so this variable is typed as a String type. Likewise, age is typed as an Int, temperature is typed as a Double, which is the default floating-point data type in Swift, and activeMembership is a Bool. Again, Swift is a type-safe language, and Swift will check that your types are correct and consistent at every possible opportunity throughout your code. And once Swift has inferred a particular data type for your variable, like playerName here is inferred as a string, if I then try and treat playerName as an integer, I'll get an error. Cannot assign a value of type Int to type String. PlayerName is a string. We can't treat it as an integer. You might be able to get away with that kind of vague and ambiguous code in JavaScript, but you can't do it in Swift because it will enforce your data types. Now a quick sidebar. For those of you who are coming from a JavaScript background, you're probably are familiar with the keyword var, but you might think of it as a word that's useful but optional. It may be a best practice, but it's not technically required. You can make variables without writing var. And you could be wondering is it the same in Swift? So let me be clear. 

var
No, absolutely not. Here in Swift, var isn't some voluntary keyword we use at our discretion or only in certain places; it is required. And in case you're wondering, var is not one of several options we have for creating a variable; it's all we have. There is one, just one, and only one keyword to declare a variable in Swift, and that's var. Back to the playground. You probably noticed this gray section on the right-hand side. This is the results area. It's one of the big differences between writing Swift in a Swift playground and just writing Swift in some generic code editor or text editor, because an Xcode Swift playground can show us the results of our Swift as we're writing it. And where we don't have to explicitly save or compile or execute our code, we can either run this playground code manually, or we can even have the playground automatically update and refresh whenever we change anything. And there's a 

couple of ways to run our code. As I'm adding new lines, I'll get this play button appear on the left-hand side. You'll see it change from line to line as I'm mousing over. And the lines that are highlighted in blue are telling me which lines will be executed if I press that play button. The results pane on the right is going to show me the effects of any expression for every line. 


So here what I'm seeing is the values of these variables as they're being created. But if I add a simple line to perform a basic operation, like changing the value of the age variable, I don't see any results on the right-hand side because I haven't executed this code. I could come over here, press the play button on any of these lines, and in a moment I'll see those results appear on the right. 
So here I'm seeing both the original state of the variable when it's created on line 3 and then when it's changed on line 7. And I don't have to write an explicit statement to print out this value. It's automatically showing me the results of the operations on every line. And because I only ran a couple of lines of code, the freshest results here are showing up in black whereas the previous results are showing up in gray. If I move my mouse over line 7 and I have all the lines hinted in this blue highlight, I can press that again, and after a second they will all show up in black with all of the results reevaluated. But at the bottom of every Xcode playground, I'll also see these two buttons. 

The first one allows me to toggle this debug area on and off. Right now this area isn't that useful, it's blank, but as we start to write more code, we can use this area to log diagnostic messages and see more behind the scenes output coming out here. 



But right now this second button is more useful. It looks either like a play or a stop button. It allows me to either execute the entire playground or press stop to stop executing the playground. And if I hover over it, I'll also see this little disclosure triangle that if I click and hold I get the option to either manually run the playground code, that's the default, or I can choose to have the playground automatically run whenever it detects a line has been added or changed. 




Now personally, I leave this on the default of manually running, but for the purposes of this course, I'm going to change it to automatically run, and just assume that I'm going to set all my playgrounds to automatically run from this point on. And this is so you don't have to hear me say now click the button to execute the playground a thousand times. I'll just have these playgrounds automatically run. 

Now there are a few more features of a playground, but we need more interesting codes to work with first. We've created simple variables with explicit values that Swift can easily understand and infer. It's time to see what happens when we can't provide that initial data. But first, a quick sidebar.

Sidebar: Writing Swift in the REPL
This is the first of a few sidebar moments we're going to have in the course. Think of these as like a sidebar or a footnote in a book where we just kind of step out of the main flow just for a moment to quickly cover a related topic. You see, there is an alternative to playgrounds, another way to write a few lines of Swift using a feature called the REPL. A REPL, it's R-E-P-L, which stands for read-evaluate-print loop, is something we do at the command line. It's a feature that lets us write and immediately run a single expression or a single statement. Now REPLs first came from the language Lisp, though many languages now have a similar feature. It isn't always called a REPL. There's other names like interactive mode or interactive shell. But if you've installed Xcode on your Mac or you've installed the Swift tools on Linux, you can open a terminal window, type swift, and hit Return. That's it. After a few seconds, we're inside the Swift REPL. I can tell because up at the top of the bar you'll see those letters, repl, and a bunch of other terms mainly to do with the CPU I'm running on. But let me bring your attention to these letters, lldb. I'll come back to these in about 60 seconds. In this REPL I can now type Swift expressions one line at a time. Each line I write is read in, that's the R in REPL. It's automatically evaluated. That's the E. Any results are printed out. That's the P. And then finally, L, it loops back to the first R, ready to read whatever I type next, and this repeats. I type lines of Swift. Each one is immediately read in, evaluated, executed, and the results printed to the console. And it stays aware of other code I've written in this session, so I can write new expressions that refer to the previous lines. It is also smart enough to recognize when I haven't finished a statement. So I could write an if statement, and the REPL won't try to evaluate this until it's actually finished. Okay, if you have a background with scripting languages or shell scripting where you're used to REPLs or interactive modes, you'll have a good idea of what you can do with this. However, if you have more of a classic applications developer background where you've been writing desktop apps or mobile apps, there's probably part of you looking at this REPL right now and thinking I don't get it. What's the point? Why would I use this? Why would I want to write one line of code at a time at a command prompt when I have a full IDE or code editor? And you're not wrong. It's true we're not going to write Swift applications in a REPL. That's not what it's intended for. See, a moment ago I pointed out those letters lldb, and you see them because the Swift REPL is actually part of LLDB. And LLDB is the debugger tool for Swift on all platforms. Even if we're using Xcode to write our Swift, Xcode uses LLDB behind the scenes to do any debugging. So yes, you're not going to use the REPL to write applications, but instead, cast your mind forward a few months from now. You're in the middle of debugging a large and complex Swift application. To be able to go to the command line, write a line of Swift, and immediately have that line evaluated and executed, it will let you test something, check something, change something as part of your debugging process, it's that kind of situation where this ability can come in very useful. But now we've seen the REPL. This is all I'm going to do with it in this course. We don't need to go any deeper into it here. For what we want to do, playgrounds are a much better fit. But that's how you can get to it. That's how you can start to use it. And to quit this session of the REPL, I simply type :quit. That's it. End sidebar. Let's move on.

Sidebar: The Swift Compilation Process
While we're making a few comparisons between Swift and other languages, there's probably a few folks out there wondering okay, Simon, now what about compilation? How does Swift get converted into machine code. Is this language more like Python or more like C++ or more like Java? Okay, to answer this, let us take popular programming languages as falling roughly into one of three categories. We have the languages that are usually compiled, like C, C++, where your source code is fully converted into machine code well in advance. We have languages that are typically interpreted, JavaScript, Ruby, where your source code is not compiled in advance, but run through an interpreter when somebody wants to run that code. And languages somewhere in the middle, like Java or C#, converted into an intermediate language, also called bytecode or p-code, with the final step to machine code happening as needed. And yes, okay, there are always exceptions and edge cases. I'm talking about the typical way these languages are implemented. So, Swift is compiled. It's not interpreted. It's not taken to an intermediate language. A typical Swift application is compiled to machine code. So for those of you coming from say .NET or Java, understand there is no Swift runtime engine or Swift virtual machine that everybody must install before they can run your app. Swift compiles to machine code. 

Now if you're wondering was it totally necessary I talk about this right now, well, there is a reason, because when we begin Swift by experimenting with the playgrounds or the REPL where we get this automatic line by line execution, some people assume Swift must then be an interpreted language, but it isn't. We can do those things because we have really good tools. But in typical usage, Swift is fully compiled in advance. Now let's get back to writing it. End sidebar. On to the next module.

 
SIDENOTE: Swift compiles the machine code

Piece by Piece: What Your Data Means
Understanding Variables in Swift
Let us now go one step deeper into variables. I'm going to tell you all the rules to create as many Swift variables as you'll ever need, and then I'm going to try and persuade you to not create very many of them anyway. So we have this straightforward format. 

To make a variable in Swift, we use the keyword var. Again, it's the only keyword to make a variable, and it's not optional. Provide our choice of variable name in lower CamelCase, and if we can provide an initial value, we'll get type inference where Swift infers the type from the value. But what about when we need to make a new variable, but we don't have a value for it immediately? Perhaps we expect to calculate this value based on the day of the week or the predicted temperature at 5:00 a.m., or we'll ask the user, or we'll get it from a database or over the web. 

Well, we still use var to define this variable. But when we don't provide a way for Swift to infer the type, then we must explicitly tell Swift what the type of this variable is, and that's why this code right now is showing an error. Swift has no idea what type of data this variable is supposed to hold, and that's unacceptable. 
Providing the Variable Type
So, to provide the data type, after the variable name we write a colon, a space, and then the type. For example, colon, space, Int. Int is the built-in integer data type in Swift. And that's it. We fixed the error. Xcode is now content. Even though this variable doesn't yet have a value, Swift now knows the kind of value it is allowed to have. You can think of the colon as meaning of type. So this line means make a new variable called bonusScore of type Int, or make a new variable called environmentName of type String, or a new variable levelCompleted of type Bool. And in Swift, the convention is that our variable names begin with a lowercase letter, but the type names themselves begin with an uppercase letter, Int with an uppercase I, String with an uppercase S, Bool with an uppercase B, and so on. When writing this, you can put a space between the variable name and the colon, but the accepted style in Swift is that we don't. It's no space before the colon. It comes immediately after the variable name, then one space, and then the type. 

Now these two pieces, the colon and the type name together is called the type annotation. We are annotating our new variable. We're marking it. We're adding notes to it to say what type it is. And if I don't have that and there's no value for Swift to infer, that's the error that we've already seen in Xcode, Type annotation is missing.

 So what are our choices for types? Well, there are several basic types built into the Swift programming language. We have what you might think of as the usual suspects. 
Int for integer values. There's a very powerful Unicode where 
•	String 
•	Double
•	Float 
•	Double is 64-bit, 
•	Float is 32-bit
•	Bool for true or false
•	UInt for an unsigned integer
Character type just for a single character. But I'm not going to try and be exhaustive here. This is not the time or the place. Just expect you will find a few other options. If you're declaring, for example, a variable that you want to be an integer, after typing the colon and the I, you'll see Xcode's autocompletion pop up different options, not just the regular Swift Int, but specifically the 8-bit version and the 16-bit version. For the moment at least, we're going to begin with the basics, like Int, String, Double, Float, and Bool. 

There are also three built-in collection data types in Swift. 
We have 
•	arrays
•	dictionaries
•	sets

These are all part of the standard Swift language, but we'll dive into these a little later on. In case you're wondering, you can write both the type annotation and provide an initial value. This is fine, but there's simply no point. If you've got the initial value, you shouldn't need the type annotation. 

But Simon, you wonder, what about more complex types? What about things like dates or times or having a variable that represents a website location or a file in the file system or a button in an iOS app? Well, those types certainly do exist, but they're not part of the actual Swift language itself. 

They don't need to be. We get access to those by importing additional frameworks, and we will be doing that shortly. 

Now I do want to clear up one misconception I've heard, that when we write code like this, using type inference, that Swift is somehow trying to hide or obscure the data types from us, and it's completely the opposite. Swift is type-safe. It requires us to deeply understand the data types we're working with, and because we do, we can then have more concise and readable syntax. That if I write a line like this, I shouldn't then need to add something extra to say, oh, by the way, this is a string. It's obvious it's a string. It's obvious to us as programmers. It's obvious to the compiler. There is nothing ambiguous about it. So in Swift we don't need to write that data type as long as we understand that type inference is happening and that the behavior of this line is exactly the same as if we had explicitly written a data type. 

We lose nothing by removing it, so we remove it. And as we get deeper into Swift, we will see this kind of thing again. There'll be other places where we can just omit pieces of syntax. Things we would expect to write in other languages, we just won't have to write here.

Constants: Why They're Important
Variables may not be the most compelling of subjects, but let's face it, as programmers we know they're important. We'll spend a lot of time defining all these specific individual pieces of data we need throughout our programs.  We'll name them. We'll give them a type.  We'll provide values for them. But I'm now going to attempt to persuade you that in Swift, when you are defining all these pieces of data you need in your code, you avoid the var keyword when you can and use a different keyword, let. Var creates a Swift variable; let creates a Swift constant. It is still a piece of data we're defining and naming. The difference is we can only set the value once. Any attempt to change it after it's been initialized will cause an error. Once it's set, it cannot vary, so it is not a variable. If you're thinking, okay, but what's the big deal? Lots of programming languages support constants. Well, this is one of those places things are a little different in Swift. Again, not very different, but a little different. Let us get clear on the syntax first, and it is simple. In some other languages you do this kind of thing using additional keywords. You'd first define a variable, and then to turn it into a constant, you'd tack on some extra keyword like const or final or readonly. 

In Swift, it's not an extra keyword to make a constant, it's a different keyword. 

We simply swap the keyword var with the keyword let. Everything else about the syntax is identical to what we've already covered with variables. So here in Swift the style is to name your constants just like naming variables, CamelCase, lowercase first letter. And just like variables, if we can initialize our constant with a value as we're declaring it, Swift will infer the data type. And again, just like variables, if we can't provide that initial value for Swift to infer, we must then use a type annotation to say what the data type is. The syntax is easy. 

What's important in Swift, what's different in Swift is that we actually do this. You see, there are some programming languages where you can make constants, you just don't see many of them, where the culture and the practices that have evolved, I mean you can read a lot of code without ever seeing one or only in some specific circumstances. Let's face it, in some languages, about the only thing people do with constants is use a few as a convenience to provide some names for a handful of hard-coded literal values like the value of pi or the IP address of a server. But not here. In Swift, constants are highly encouraged. And as you learn this language and you read sample code and you explore projects or watch conference talks, you will see the keyword let everywhere. In fact, one of the signs of well-written Swift code is when whoever wrote it seems to have a habit, a default mode of defining, well, pretty much everything with let and only using var when they know for sure a piece of data has to change. And this encouragement goes so far that when writing Swift in Xcode, if we define a variable and the compile detects we don't actually need it to be a variable, we will get a warning. Here I have a simpleFunction, create a variable called message. I'll initialize it, giving it a value, and then I'll print it out. The variable is created correctly, and it's being used, but there's no code that could possibly alter this after that first value, and Xcode pops up a warning. This warning shows up in orange, not red. Red would be an error. And it's true a warning won't stop us from running our code, but it has detected a fixable issue telling us that this variable is never mutated, it's never changed, and it recommends we consider changing this var to a let. It even supplies what's called a fix it. If I click the orange triangle, Xcode offers to change this code for us. If I click this line, it will. This might seem like a tiny change, and technically it is, three letters. 

 What we're starting to see here, and we'll see it again, is that Swift focuses on writing safer code. Swift will often encourage you, and yes, sometimes require you to be a little bit clearer, a little bit more specific than you might have to be in other languages. In Swift, if there's a place where we can tighten something down, if we can prevent unintended behavior, we will. We've already seen that Swift is a type-safe language. We can't treat a string as if it's an integer, we can't treat an integer as if it's a Bool, and this takes it a little further. If we define a variable, give it a value, but there's no logic in the rest of our program that could ever change it, we will be encouraged to make that a constant, to be explicit not just about what the type of that piece of data is, but also how we're going to use it, that we're going to set it, and then we're not going to change it. 
 
 Now the skeptical among you may ask, okay, but is there an actual benefit, a measurable difference of using constants over variables? First and foremost, it is a way to write safer code, but yes, beyond that, the Swift compiler will make optimizations for constants that it won't do for variables. Because when you are explicit about your data that doesn't need to change versus your data that does, it can be made more efficient; it can reduce overhead. So getting into this habit is something that not only makes you more of a Swift-style programmer, it is objectively a way to write more efficient code here. 

Now to wrap this up, there is one thing I want to point out because some programmers may be used to a language where values of constants have to be known at compile time. So just to be clear, in Swift, the value of the constant does not have to be a literal value. It does not have to be fixed at compile time. You can just define a constant using a type annotation to say it'll be an Int or a String or a Float or anything else without giving it a value as long as somewhere else in that program there will be logic to initialize it. And that constant could be initialized differently every time the program executes, but again, just once. And the Swift compiler is going to check your code to ensure two things, that 

first in a Swift program everything you define, both constants and variables, must be initialized before we attempt to use them. I can define a constant without a value. That's okay. If I try to print it out before it's been given a value, that's not okay. I will get an error. It must be initialized before we use it. 
The compiler will also check that when you have initialized your constant that there is no logic somewhere else in your code that could potentially change it, which would also cause an error. This seems like a lot of errors, but bear in mind these are the kinds of errors we want, a compile-time error, an error we get as we're writing our code that is alerting us that there's a mismatch between what we said we were doing with a piece of data and what we're actually doing with it. So as you're getting into Swift, make an effort to use let as much as you can. Most programmers who aren't in the habit of using constants are surprised by just how many pieces of data just will need not need to change after you've given them their initial value.

Introducing Operators

Let's assume that with any programming language we'll have a collection of operators to use when writing our code. Most operators are just symbols, like having equals or the plus sign. An operator could be more than one character, like having the double equals or even the triple equals. And of course, you'll find certain operators exist in some languages, but not in others. There are languages you might use a word where in a different language you'd use a symbol. But the idea is the same, that any operator is a shorthand way to do something specific, to perform some operation, hence operator. Alright, nothing new so far, but here's the catch. It is easy to assume, well, Swift is a C-style language, so if I already know the operators in another C-style language, I'm good here, right? And no, you would not be good. Again, things are a little different here. Now it is true there are plenty of operators in Swift that work identically to, well, let's just say just about every other programming language, assignment, addition, subtraction, multiplication, division, greater than, less than. If you've used these anywhere else, assume they work the same way here. 

And we won't spend much time with these simple ones. But there is another group, operators you won't find in many other languages, which are vital here in Swift. The double question mark, the three dots, the two dots, and less than sign. Even things like the single exclamation mark and the single question mark, which are often used in other languages have their own specific meanings in Swift. And they aren't esoteric or unusual. These are operators we will use all the time. Even if you never intended to write Swift and your only reason for watching this course is to feel a little more comfortable reading it, you need to know all of these. 

And to offset the fact that we have a few new ones, there are also a handful of operators which are very common in other languages, and you might assume they exist in Swift, but they don't. For example, the common increment and decrement operators. The ++ and -- that you'll find in many other C-style languages do not work here in Swift. So, we have a bunch that work as they do in most languages, we have a few new operators to learn for Swift, and a handful we can just forget about. 

Now with these new ones, I'm not just going to go through a list of all their definitions now because that'll be a great way to forget half of them. I'll introduce the new operators as we need them, which will begin in the next few minutes. But before that, let's use a few of the easy operators first, the ones everybody kind of knows, because as soon as we start using them here, more will be revealed about Swift, how it works and how you need to think. And I can prove this with some of the simplest code in the world.

Converting in Swift: When It Happens (And When It Doesn't)
In a new Xcode playground, here is that simple code I promised at the end of the last clip. Let a = 5. Let b = 2. Let myResult = a + b. Now if you roll your eyes and think, really? This is a course for professional programmers, and he's actually going to talk about how to add two numbers together? No, the addition here is not the important thing. The key question is I now have three constants; what data type are they? This is Swift. Everything has a type. And I didn't write a type annotation, so Swift is doing type inference for all of this. Now for the first I provide this literal value, the number 5 with no decimal point, so this will be type inferred as an Int because it looks like an Int. And likewise, so is b, and so is myResult because it's inferring the type of this based on how we're providing its initial value, and that's using an expression that adds two integers together. And Swift will assume that the result of an integer calculation is also an integer. If you're wondering if we can prove that this is type inferred as an Int, yes, there is a simple built-in Swift function to ask what the type of a variable or constant is. It's written like this. This syntax with the colon and the space might look a little unusual. We will get to this very soon. And over on the right, the output from calling this function tells me myResult is an Int.Type. Here's the next step. I'll change this addition to division, plus sign becomes the forward slash, and now it's 5 divided by 2 giving our result. And if I look over on the right of the playground, it says the result is 2. But of course, 5 divided by 2 is not 2. It's 2.5. It's once again we're getting type inference. And once again, if I'm using two integers, the result of the calculation is another integer. So anything that comes after a decimal point will be truncated, not rounded up or down, just ignored. One way I could solve this is by changing a and b to be both floating point types either using an explicit type annotation or by just changing their initial values to include a decimal point. When the playground realizes this is done, it considers them to both be doubles. Again, that's the default floating-point data type in Swift. And the result of a calculation with two doubles is another double, and we get the correct result of 2.5. Okay, but what if I actually wanted or needed to leave a and b as integers, but I still wanted myResult to be a floating-point type? If I were new to Swift, here's one thing I might be tempted to try. To add a type annotation to explicitly say I want this to be a type of Double. I do that, and not only does this not provide the result I want, unlike many languages, it gives me a compile error, the red stop sign. This code is broken, it will not run, and this is happening because in Swift we don't have implicit conversion between types. This is a very important point in this language, so let me say this again with trumpets and fireworks. In Swift, we don't have implicit conversion between types. By this, I mean here, Float is never automatically converted to an Int. An Int is never just automatically treated as if it's a Double or a Bool or a String, and that's true for more complex data types as well. Now, in many other programming languages, even ones that are strongly typed, we often have some implicit conversion also called coercion. If you're using C or Java or in this example, C#, and you write a calculation that uses, say, an integer value together with a floating-point value or perhaps an unsigned integer together with a signed integer, many languages will do their best to make those calculations just work. And this can be very convenient much of the time. Let's even say 99.9 % of the time. Any automatic implicit conversion a language does for you is going to work out just fine. It'll be what you wanted, what you expected, and very occasionally it won't be, and that's the problem. The edge case is when an automatic conversion leads to something we didn't foresee, like a value we assumed was being rounded up or rounded down we only later figure out as being truncated all along, or there's a value that should be allowed to be negative, but once in a while it's being flipped to positive because of how it's being passed from one part of the program into another. And these bugs are often incredibly difficult to diagnose because they're not about any code we wrote. It's about some transformation that's silently just happening. Well, it doesn't happen here because Swift doesn't do this at all. And let me assure you this includes things that would just work in most popular languages. Here I'm going to make two Swift variables. The first one I'll give an initial value of 1. This will be type inferred as an Int because it looks like an Int. The second, initial value of 100.0. Again, because of the decimal point, this will be type inferred as a Double. And then sometime later in my code I will innocently attempt to set the value of the highScore variable to whatever value is in the score variable.  Now this kind of thing would just work in many, perhaps most popular programming languages, and will not work in Swift and gives us an immediate compile-time error telling us you can't just take an Int and shove it in a Double as if they're the same thing. If you're coming from a language with any kind of implicit conversion, there will be moments while learning Swift where you'll write a simple operation like this, you'll get an immediate error, and you'll want to say, oh, come on Swift, give me a break. That would totally always work. But the danger is in anyone thinking this indicates a lack of ability with Swift. It doesn't. It's completely intentional. It's because Swift has a different mindset about this kind of situation. You see, most languages at this point are asking the question can this be made to work? Can the value of this one type be automatically coerced into a different type? And sometimes yes, other times no, and other times, well, it'll probably work. You could lose some information, or you could lose some precision when the conversion happens, so we'll just assume you've thought about every possible eventuality and just go ahead and do it anyway. But in Swift we don't have to memorize rules of implicit conversion about what is allowed and what's not allowed and what all the edge cases are. It is wonderfully simple here. If there's a mismatch, the Swift compiler will stop you. Understand an error like this is not trying to bring my project to a screeching halt. It's actually more respectful. It's asking me to bring my attention to the fact I've got a line here that treats two different types as if they're interchangeable when they aren't, and that what happens now is up to me. It's my decision, not Swift's. Just in case anybody's thinking, well, this sounds ridiculous. Are you telling me Swift can't even convert between an integer number and a floating-point number? Of course it can. Swift can convert in a flash, in a heartbeat, in two shakes of a lamb's tail, and it's easy, but you have to say you want it to happen. That's the difference. Conversion in Swift is explicit and intentional, not implicit and automatic. Let's see a few examples.

Making Conversion Happen
In any nontrivial program, we'll need to write expressions involving different data types, and not just different numeric types, we'll also have strings, and soon things like dates and times and collections, structures, and objects, so we'll need to combine some pieces of our data and compare other pieces of our data and concatenate yet other pieces of data. But in Swift we are explicit about any conversion, that when we have interactions between different types, even something as basic as adding together an integer and a float, we recognize this result could be different if we decided to treat the Int like it was a Float or the Float like it was an Int. 

 And we can do either, but in Swift it is up to us. Let's go back to the breaking code from the last clip where I simply want to take the value of this in this integer variable score and assign it to the double variable highScore. Here the interaction is pretty straightforward. We need to make the integer into a double. 


A  nd because this is so predictable, we're even offered a suggested fix it by Xcode, where it's basically saying, hey, these are different types, so you have to make this explicit, but I am guessing this is probably what you want to do here. And the fix it is indeed the syntax that I need to make a new double based on our integer value. The arrow goes away. We're now making this conversion explicit. And it's a similar syntax if we wanted to convert an Integer into a Float, or convert that Float into a String, or take that String and make it into a Double, or take the Float we just made from an Int and use it to make another Int. 




It's just the name of the type we are converting to, and again, in Swift type names begin in uppercase, then inside parentheses whatever value we're converting from. The syntax is straightforward, but I'm not going to pretend that we're finished here because not all conversions are the same. 

There's three things to understand about this, true for any language, but worth covering here. First, you can't convert any type into any other type. Some conversions just don't make sense. For example, if I make a variable that's a Bool holding either true or false, it is meaningless to ask to convert that to a floating-point numeric Double value, and if I try, Swift is going to give me a compile error. But when we are doing a conversion that does make sense, one that's allowed, it is possible to still lose information, of course it is. It's a conversion. If you choose to convert a Float to an Int, then, yes, it's going to work, but you're going to lose anything that might have come after the decimal point in the Float value. Or if you chose to convert a very long and complex integer into a 32-bit Float, you could lose precision because it won't all fit. The point is simply that in Swift, whatever conversion we're doing, we're doing explicitly, and it's always obvious that it's happening because it's in our code, not behind the scenes. And point three, and again true for any language, but with particular impact here. Even when a conversion from one type to another type is allowed doesn't mean it will always work. Now it's true some conversions will. If I begin with an Integer, whatever possible value that is, from the smallest to the largest, I could always ask to convert that integer to a String type, and that will always work, and not an unusual thing to do. Perhaps I want to use that Integer as part of an error message or dialog. But I could also go with the other direction, take something defined as a String value and ask to convert that into an Int or a Float or a Double. And again, not unusual. We'll often get String values from user input from filling in forms and so on and need to convert them. 
 


Now if the value of the String is numeric and makes sense as an Integer, Swift can and will convert it. But what if that String value isn't numeric? Let's imagine we're getting this value from a user. Perhaps we asked them for their age. We hope they type in something numeric but we can't guarantee it. Then what happens? What do we get if we try and convert this String into an Int? Well, first, one thing we won't get is an error, neither at compile time nor at runtime, because there's nothing wrong with the syntax here. There's nothing wrong with asking to convert a String to an Int. We have to be able to do this. But we also recognize that just because we tried to do it doesn't mean we're always going to get an Int out of this. It's going to depend on whatever value is in the String at that moment. 

So String to Int is an example of a conversion that may or may not succeed, but I can always try to do it, and when I do, I may get an Int, or I may get nothing at all. Now let me be clear. I'm not showing this because I think you should memorize the exact syntax and every detail of Integer to String, and String to Integer, and Float to Double, and Double to Float conversion. 

	
As long as you get the basic idea, you're fine. You can always look the specifics up. What I do want to do here is use this example to introduce an idea, an important concept, that in a real-world program there will be times we want a meaningful piece of data, and we can even define that piece of data very well. We just know we won't always get it. Perhaps in our program we'll define some strings to hold someone's first, last, and middle names, but when we go to get that, they don't have a middle name, so there's no value to put there. We'll call a function to download an image from a remote server on the cloud, but the user has just turned off their network connection, and we'll never get that data. Or we simply try and convert a String like this into an Int, but we realize that String might contain garbage, so it might not succeed. Because this idea leads us to one of the most important parts of Swift, something else that is a little different about this language, and it's not hard to understand, but it will have deep, deep implications for everything we do going forward, the idea of what we call optional values or just optionals.

 
Optionals — An Introduction
In Swift, we can define constants and variables without immediately giving them a value. We can begin with just the name and the type annotation. But if this is all we've done, we couldn't use any of these in any calculations or operations yet because they haven't been initialized. 



And yes, Swift cares about that. If I try something as simple as just printing out the value of 1, we will get an error, not a warning, an error. 

In Swift, variables and constants are not automatically initialized to default values. And let me say that again. In Swift, our variables and constants are not automatically initialized to default values. I stress that point because in several other languages, if you declare variables of a string, an integer, and a Boolean and don't provide values for them, you'll get defaults, you'll get an empty string, an integer that's 0, a Boolean that's false. But not here. It's yet another safety feature of Swift. Because in other languages the fact that you can write code using a bunch of items, whether they have or have not actually been explicitly initialized, can lead to unpredictable behavior. Most of the time it'll be okay, and sometimes it won't, and things break. So in Swift the compiler scans through all your code to ensure that somewhere there is logic to initialize all constants and variables before you do anything else with them, and that takes care of one potential issue. But if everything has to be given a meaningful value before we can even look at it elsewhere in our code, what about those times when we have a piece of data that legitimately might not get a value? A simple example, as in the last clip. We're writing an app for a travel agency, and we know we want a few variables to hold traveler details like name and email information. And we know sometimes there will be data for a middle name, and sometimes there won't. Sometimes there will be a secondary email address, and other times there won't be. And focus on the idea. We're not talking about where we're going to calculate a value or retrieve one from a database, we just haven't gotten around to it yet. We're saying that based on the logic of a program, there may be times when there is truly no value for a piece of data and where that is okay.  Now a few programmers might think, well, when you set these values, if they don't have a middle name, just set it to empty string. But first, that's not quite right. The person doesn't have a middle name of empty string, they just don't have a middle name. But more importantly, having default values when there is actually no data can interfere with your logic. For example, let's say I wanted this integer variable to hold a calculated number of days until our traveler's next trip if they have one coming up. But if this integer always immediately defaults to 0, I won't know if 0 means we calculated the next trip starts today, or 0 means we haven't yet calculated when the next trip is, or 0 means there is no next trip, and sometimes there just isn't a meaningful value here. It's just one reason why Swift doesn't do these kinds of default values. 
 
 Here, we handle this kind of situation using optionals. Optionals allow us to say when a certain piece of data might have a value, and if it does, it will be of a specific type, but it might not have a value at all. To define any of our own constants or variables as optional, it's simple. In the type annotation after that variable, we add a question mark right after the type name, so String? or Int?. That's it, and notice there's no space between the type and the question mark. The way we would now talk about these variables in Swift programmer speak is that firstName might be type of String, lastName is type of String, but middleName is now type of optional String. DaysUntilNextTrip is optional Int. It might have a value. It might not. And notice we're always adding that question mark to a type. So I might talk generally about the concept of Swift optionals, but each one we make is always an optional something, an optional String, or an optional Int, or an optional Float, an optional Boolean. So let's get clear on a few things. 
First, a Swift optional does not imply any kind of flexible or ambiguous value. They still have that type. Adding the question mark to something defined as an Int doesn't make this new variable maybe an Integer, but now maybe a Boolean or maybe an image of a cat. No, this will either contain an Integer value or nothing. Not 0, but no value at all. 
Likewise, if secondaryEmail is now made into type of optional String, it may or may not have a value, but if it does have a value, it must be a String. And in Swift we use the keyword nil, n-i-l, for this concept of devoid of a value. And we now see that word here in the playground result showing the current state of these three optional variables. They are shown as nil, no value, because for them, nil is okay; it's allowed. I want to point out that the other, let's call them normal variables, aren't showing anything. They aren't nil because that's not an allowable state for them. These ones must be given a value before we'll do anything with them. They just haven't been initialized yet.  That might sound like a nitpicking point, but it is important. Nil does not mean uninitialized. It does not mean what all of our variables and constants are before we've given them a value. No, nil is only meaningful if something is defined as an optional type. 
 
So with a variable defined as an optional Integer, I can give it a value, and if I want to, I can set it back to nil. I can then later on give it another value. I can set it back to nil again. 

 But when a variable is not defined as optional like firstName here, it can't be nil. It doesn't begin as nil, we can't set it to nil, and we get an error if we try. 


Quick sidebar. For those of you coming from languages where you use the keyword null, it's really not the same thing. Null is a word that usually applies to objects or object references, but in 

Swift we can have optionals of any type, optional integers, optional Booleans, floats, strings, and yes, optional objects, optional arrays, optional images, optional buttons. Whatever type you have can be used either as that type or as an optional version of that type. End sidebar. 


But there are two aspects to optionals in Swift, because if we're starting to say that some constants or variables are now allowed to be nil and not have a value, then later in our code when we use these, we can't just write them into a calculation or operation assuming they always have a value because we've said it's okay if they don't. So we need both this small change in syntax when declaring optionals, but we'll also need a change in syntax when we start to use these optionals so that we can ask at any moment does that actually have a value or not? Now for anyone out there in internet land who might even be zoning out a little, who might be hearing all this and thinking, oh, this optional stuff all sounds a little theoretical, a little academic. I've gotten along fine in my programming career without optionals, so I kind of get the point, but I think I'll probably just won't use them very often. Well, you will have no choice. 

Optionals are an absolutely essential part of normal everyday Swift programming. 

As soon as we do anything in Swift, we're going to have optionals, and that's because you won't only have the optionals you define yourself by adding that question mark after the type, that will be some of them, but in addition to those, you will also naturally have to deal with a lot of optionals just from doing typical programming stuff. There are many places where you'll use a piece of built-in functionality in the Swift language, and what you will get back will not be a String or a Float or a Double. It'll be an optional String or an optional Float or an optional Double. And yes, as we get more advanced, perhaps an optional array or an optional file object or an optional image object. Optionals are everywhere, and they become even more vital when you get to iOS or macOS development. So we've talked here about what they are and how to define them. Next, we're going to see how to use them, whether they're the ones we've defined or the optionals we just end up with from doing something else in Swift.

Unwrapping Your Optionals
When dealing with optionals, there are extra steps. We cannot treat an optional value exactly the same as a regular non-optional one. Okay, there are a few times we don't care about the difference. If I've got two variables here, one is of type Int and one is of type optional Int using the question mark, and notice in the playground, the optionalInt variable shows as nil, which for this one is an allowed state. So I can just assign a new value to either of these exactly the same way. This code works for regularInt, it works for optionalInt because when just assigning a new value, we don't care if they're optional or not. It doesn't matter what value they contained or even if there was a value. And with an optional variable, I can also assign that to nil if I wanted to remove any value, but again, I can only do this to an optional. This would cause an error if I tried to do it with the regularInt variable. But the most important difference comes later in the program when I want to use these in some conditional calculation, even something as simple as just add 5 to the current value. Now I can use the fairly typical programming syntax here of regularInt = regularInt + 5, but if I try that code with the optionalInt, I get an error because adding 5 to something assumes there is a something for us to add 5 to. 


But Swift is looking at this line and saying, yeah, but this is an optional Int variable. I'm not going to let you do this because this might be nil. You can't add five to a nonexistent value. So what do we do here? We need to understand just a little bit more about how optionals work. And here's the thing. 

When anything is defined as an optional type, it's as if we take the underlying data type, the integer or the string or the array, whatever it is, and we wrap it up. Any value gets placed inside this optional container. It gives us this extra step we need to get to it, and that's because there's one question we always have to ask when we have an optional anything. 

First, does this have a value at all? Is this optional nil, or is it not nil? Now if the optional is not nil, we then know it contains a value. We can then reach in and pull that value out, and that's called unwrapping. 

We unwrap the optional to get to the actual value inside. But the important point, we only want to unwrap when there actually is a value. So there are few different ways to unwrap an optional. 

 

And I'll admit the first method I'm going to show you here is one you will end up using the least. It is the most verbose, the most long-winded way to do it, but it makes every part of this obvious, which is why it's worth doing first. 













// Using Optionals
var regularInt: Int
var optionalInt: Int?
// can
set
values
regularInt
100
optionalInt
   =
100
// check for nil








•	We can begin by writing a condition to just ask if a particular optional is equal to nil. 
•	Now we haven't officially covered if statements, and that's in a few minutes, but this should be readable enough. 
•	In Swift, we use the double equal sign to test equality.
•	So if optionalInt is equal to nil, we will do something. 
•	But actually, if it is nil, we'll just ignore it. 
•	What we're interested in most of the time is something being not nil, which for us is the exclamation equals. 
•	If optionalInt is not equal to nil, we then know it contains a valid integer value. 
•	So now I can unwrap the optional to pull out the integer we know is inside. 
•	And one way is to use this exclamation mark after the optional name. 
•	And it's immediately after it, no space. 
•	So we used a question mark to declare this as an optional.
•	We can use an exclamation mark to unwrap the optional and get to the value.
•	Using an exclamation mark like this is called forced unwrapping.
•	We're saying we know this has a value, so unwrap it.
•	And if we use this method, then it's up to us to make sure that we have checked for a non-nil value, because if I don't check it first and just force unwrap the optional, but it doesn't contain a value, it will crash the program.
•	Let me say that again.
•	If you force unwrap an optional, and that optional is nil, you'll get a runtime error.
•	So you'll only force unwrap when you know there's a value, which is the entire point of having this if statement.
•	Now I'm making a new variable here on this line, unwrappedInt, and this will be typed as a normal integer, not an optional integer because Swift once more is doing type inference to make this variable.
•	And we provide a value by unwrapping the optional, which means we unwrap and pull out a regular integer value to create it, so this will be a regular Int.
•	And I could add some code to manipulate or use this value, and there'll be no problems with it.
•	So this is one way to do it, but as I said, probably the most verbose way to do it.
•	So let me show another way to unwrap optionals that's a little more concise, and that's this way using the if let syntax.
•	Now this often looks a little strange the first time you see it, but in Swift you'll see it a lot.
•	And the way you should read this is this part first, let unwrappedInt = optionalInt.
•	Even though we're not using the exclamation mark here, when we use this syntax, this if let statement, it'll check the optional, and if it's not nil, it will make this new constant from whatever is inside it.
•	And if it can do that, there means there was a value in the optional, and then this if statement is considered true, and we jump into the body of it where we will have this new unwrappedInt constant available to us.
•	So we aren't using the exclamation mark here as this is the unwrapped value.
•	But if the optional is nil, then we can't unwrap, this let statement doesn't work, we will have no new constant, and this if counts as false.
•	So if there's an else block to our if statement, we jump into that; otherwise, we'll just move on.
•	And this method is called optional binding, and it's common to see.
•	You look out for these if let keywords because if you see those, you know you're dealing with an optional, even if you aren't seeing the exclamation mark or the question mark.
•	So this is two common ways to deal with optionals, using an exclamation mark and using the if let statement.
•	There are yet other ways we will deal with optionals, but we'll get into those later on.

Creating and Using Arrays
We've been dealing with individual pieces of data. We define and name one String or one Integer or one Boolean at a time. So in this clip, we're going to dive into collections in Swift, defining one item that can contain multiple values. And Swift has the array, the dictionary, and the set. Array being the classic ordered collection of items with a zero-based index. A dictionary is a collection of paired keys and values. And a set, where you need a collection of items, it just doesn't have to be in any specific order. If you're someone who's picky about their data structures and wondering, but Simon, is that all of them? What about linked lists? What about queues? What about stacks? Well, make no mistake, there are more complex data structures available in Swift. As with most other languages, we can link to other frameworks, additional ways to get in new features and new abilities into our program. Now what I'm talking about here, the array, the dictionary, and the set, these are part of the syntax of Swift. They are built into the language itself, and the others aren't. So we don't have to worry about importing or linking to anything. We can just make them and use them. First, let's talk about arrays in Swift. We'll see the others a little later. But there's three things we can cover here before we even see the code. One, arrays in Swift are zero-based. Now that shouldn't be surprising, we're in a C-style language after all, but still it's worth mentioning. If you have an array of 10 items, it's indexed 0 through 9. Next, arrays, like everything else in Swift, are type-safe. We create an array of something, an array of strings or an array of integers or an array of image objects or an array of user interface controls, but always something in particular. And that means whenever you reach into an array and get an element from it, you don't have to write code to figure out what it is you have. It will always be the type of the array. You index into an array of strings, you'll get a string back. You index into an array of integers, you'll get an integer out of it. And three, arrays, like everything else in Swift, can be declared with either var or let, and that controls whether they are variable or constant, changeable or fixed. You may prefer the term mutable or immutable arrays. If you use let, the array is a constant, so once you've provided its initial values, you cannot then change it. If you use var, the array is variable, and you can. So let's see how to make them. Over in Xcode I've got a new playground. I'll make an array of strings. The same way we've used string literals to make a String or a double literal to make a Double, this is an array literal, the square brackets with multiple values inside, each value separated by commas. And once again, type inference is happening here based on the values I use. If it's multiple strings inside the square brackets, I'll get an array of strings. If it's multiple integers inside the square brackets, I will get an array of integers. However, if I mix the values inside that, like putting a string in the middle of the integers, I will get an error. Swift needs to be able to infer what this is an array of. You can, of course, split multiple values across different lines if you find it helps in readability. And a small point, but one worth knowing is that in Swift, when using this syntax, it's okay to leave a trailing comma following the final value. You don't have to do this, but it won't mess anything up if you do. And notice that over in the playground we get a view of the data in our arrays. And here's another feature of the playground. You might have noticed this rounded rectangle that appears beside certain lines, and when you mouse over these areas, you also see this eyeball pop up. The reason for these is when we have more complex variables and constants, like having collections, we can't always see everything about them in a single line on the results panel. It just won't fit. So both of these buttons give us ways to view more of our data. The eyeball is what's called the Quick Look button. If I click it, it gives a pop-up of what's in the array. And if I click elsewhere, that'll go away. The rounded rectangle, which is called the Show Result button, shows me the same information, but instead of a pop-up, it embeds it over in the code part of the playground so I can see it there. If you don't see it all, you can expand it. And this can be toggled on and off. Now, sure, at this point we don't really need to do either, but you can probably imagine how it could be useful to view a complex collection and even leave its content visible as you're editing some other part of the code. To start using them, to access the elements in these arrays, I use the square brackets with an integer index. Again, it is zero-based, so to get the string at index position 0 it's just musicalModes, square brackets, 0. And because this array is typed as an array of strings, what I get back, this initialMode constant, is type inferred as a string. I can also use this syntax to change a value, but again, only if the array was defined with var. If I had used let on line 4, I wouldn't be able to do this. And if it is variable, I can also add a new element to the end using the append method, which I can call with .syntax. So I type in the array name, dot, and I'll get Xcode's code completion. Now see there are two versions of append here. There's one for appending a single new element and one for appending a sequence, which is basically adding one array to the end of another array. So I'll append a new element and finish with the string that I want to add. If I click on this Show Result button, I'll be able to see that we now have that new element added in at the end. Now one thing is that an array doesn't care about duplicate values. No checking is done. So we could add exactly the same element at the end again. If I click on this Show Result button, I'll be able to see it twice at the end. To remove an element, I have a few different options. Typing the array name dot r, I can see that I have removed at, which allows me to just give an integer for a specific index, remove whatever is at position 0 or 2 or 99, but I also have removeAll, I have the removeLast, I have the removeFirst methods. I can tell these are methods because they show with M over on the left-hand side. And notice that removeAll shows in here with Void before it. This means that this method will just remove all the items in the array, it doesn't return any kind of value, whereas something like removeFirst or removeLast will return a string, so it will remove whatever the first or last element of the array is, but it would also hand it back to us. So I could both write this line to remove the last element and accept that result into a new constant. Now for those of you who find it useful, this is how we could use the Swift array as a simple queue or a simple stack. Now moving on, I've created these arrays by creating a bunch of initial values for Swift to infer, but if I can't provide these initial values, I will need to use a type annotation just like any other variable or constant in Swift. So here's how we define an array of strings when we don't have initial values. We already know that to define a single string variable we'd write this. And for this variable to be declared not as type of String but as type of array of strings, I surround the type with the square brackets. That's it. Likewise, we know this is how we declare an integer, and this is how we'd turn that into an array of integers. However, these two that I've just created on line 26 and 28 might be declared as arrays, but they're still completely uninitialized. If we think of an array as a container that holds values, well, not only don't we have any values for these, we don't even have the container yet. So before we can add elements to these arrays, we actually need to create them, even if we're creating the arrays as completely empty containers, and here's how to do that. We just set them equal to square brackets with no values. Now I could do this across two lines like I'm doing here. I could, of course, just combine these onto one line. So declare myStringArray as an array of strings that is empty or myIntArray as an array of integers that's empty. Now in case anybody is wondering if I still need the type annotation if I'm providing those square brackets as the initial value, well, yes, here we still do need the type annotation. Because if I'm making an empty array, it still has to be an empty array of something, and this is how we're telling Swift what this is an empty array of. If I try to create an empty array using this format, just equaling the square brackets, I'm going to get an error. With no type annotation, it has no idea what this is supposed to be an array of. But once they've been created, and once they've been created as empty arrays, I can use what we've already seen, like the append method to start adding new items to this. Okay, so we have covered a lot of the array basics in the last few minutes, creating them, declaring them, appending to them, and removing from them. Now what you'll find is a lot of what we covered doesn't just apply to arrays, but to other Swift collections as well. But before we get to dictionaries and sets, we really need to start adding a bit of logic, a bit of control flow to our programs, and that's coming up next.

Shaping the Path: Controlling the Flow of Your Code
The Good Old 'if' Statement and What's Different About It
If Swift was exactly the same as other C-based languages with how we write control flow statements like conditions and loops, I might even tell somebody to skip part of this module. But I'm not going to because when you start to write these in Swift, you'll find the code is clean, it is concise, it's safe, and it is familiar. But again, familiar doesn't mean identical. So let's begin with the most basic, the most fundamental condition in any programming language, the good old if statement or if/else. Now, if you've written any C or JavaScript or C++ or PHP or Java or C#, I could tell you just try writing one. Just open the Swift playground, and write a simple if or if/else statement using the syntax you already know. And the code you'd write, which might be something like this, would probably work in Swift. It's an if statement, it's nothing remarkable, but there are differences in the way a Swift programmer would usually write this condition compared to how, say, a C# or a Java programmer would usually write it. So while this syntax might work, it isn't quite Swifty enough yet. There are small but important differences to know about this. Difference number one. In Swift, no parentheses are needed around the condition. In a straightforward condition, when we're checking a quality or making a comparison or testing a value, they don't help, and by removing them, we don't lose any meaning. We make it simpler and cleaner and more readable, so we pull them out. If you have a complex condition with multiple different elements to it, you can use parentheses to make that expression clearer, but they're not required. And as with semicolons in Swift, the style suggestion here is if you don't need them, don't write them. Difference number two. In Swift we drop the parentheses, but curly braces are required around each branch of an if or an else even with single-line situations. And what I mean by that is in many C-based languages this kind of code would be perfectly acceptable, an if statement with no braces after the condition where we would execute one single statement if this condition was true. This is not allowed in Swift because it's a common cause of bugs. Even a branch with a single line must be wrapped in curly braces. And to me, these two small decisions epitomize a great deal about Swift. Parentheses are not required, and being able to remove them makes our code more readable. Curly braces are required because that will make our code safer. A condition in Swift must evaluate to true or false to a logical Boolean value. Now you might think, well, duh, of course we're asking if a condition is true or false, but no, there are many C-style languages and many techniques where a condition can test for an integer value of 0 or not 0. That won't work here. Any condition must actually be a true or false value. So, examples. If highScore greater than 10, 000, this evaluates to either true or false. If the variable carModel is equal to the string Tesla, true or false? We can ask if some optional value is not nil, that's either true or false. Or of course, if we have a variable or a constant defined of type bool, we could just directly use that. If userLoggedIn, is it true or false? Or if bonusEnabled, true or false? Now when writing comparisons, the operators we use here are the standard things. We've already seen basic equality and inequality. There are the usual ones for greater than, less than, greater than or equal to, and so on. If your condition requires multiple elements to it, use the two ampersands for and, two pipes or vertical bars for or. And again, here's where you might use parentheses to make things more clear and readable or if you need to control exactly how a complex expression is evaluated. But for now, this is all we need to do with if statements. And they aren't the only way to manage a condition, so next let's take a look at how Swift works with switch statements.

Writing Switch Statements
There are times when an if/else statement is all we need. If the bank balance is positive, do this thing, else do that thing. If the player has beaten their previous high score, play sound effect A; otherwise, play sound effect B. But we also have those moments where you need to immediately branch off into multiple paths, and for this, using a switch is usually a better option than the clunky approach of either a series of if statements one right after the next, or worse, multiple levels of nested if statements. Now, if you've worked in any other language with the switch keyword or an equivalent keyword like Select Case in Visual Basic or case when in Ruby, then a basic switch statement in Swift should be fairly readable, and that even if you weren't sure about the syntax, you could look at this and say, okay, I get it. I see what this is doing. But just as with if statements, this is Swift. There are things about switch statements that are true here that aren't true elsewhere, and they're not obvious just from glancing at the code. Let us quickly review the syntax if it's new or you'd like a refresher. A switch statement lets us look at one thing. Let's keep it simple for now and just say look at one single variable or one single constant, and then react to multiple different values it could be. So let's say I'm writing a program to track catastrophes, and I need an integer called volcanoExplosivityIndex. And this actually is a scale that geologists used to categorize volcanic eruptions. It's a number in the range 0 through 8. I'll give it a value of 3 just so we have something to work with, but now the switch. We begin with just that keyword and then what we're looking at. In this case, the name of our constant and then a set of opening and closing curly braces. We don't need parentheses around it as you do in some languages. And now within the body of the switch, within the braces we write multiple case keywords for each different option we're interested in. So we want to do one thing in the case that this is the value 0 or in the case it's the value 1 or 2 or 3 and so on. And each case ends with a colon. That's a colon, not a semicolon. And then after each case, we then write the code to execute if that case is true. Here I'm going to look at the number and print the associated description for that index number. And for a level 0 eruption, it's the rather mild Effusive word. We can have one line in a case. We can have multiple lines in a case. And I'll just go ahead and build out the rest of this. Notice that the switch itself has curly braces, but each individual case does not. And if we get to case 8 of a mega-colossal volcanic explosion, there's really not much useful left to print, so this is a good opportunity to show that Swift is completely at ease with the Unicode. You can include symbols or even emoji in either your strings or your variable names themselves. Now because they're not always easy to type, you can insert them using the Edit, Emoji & Symbols menu. Now find that screaming face, and insert a few of those. All right, these are the cases that I actually care about, but Xcode is still complaining about this code, and it doesn't think that this switch statement is complete. So here's the things we need to know about doing this in Swift and where it's different from several other languages. First, any switch statement in Swift must be exhaustive. That means whatever you're looking at, all possibilities, must be covered in the switch. So if I'm checking an integer variable, I can't write a switch statement that only handles it for being a few specific values because it's an integer. While I might only care about 0 through 8, Swift knows there's a whole bunch of other possible values this integer could be. Now the simplest way to handle all possibilities for this switch to be exhaustive is to add a default clause at the end of the switch. That's just the word default with a colon. This is a special one. For this, we don't need the word case. And this just means everything else. So we first check for specific values, and then finally, for everything else, do what's in default. And because default is catching everything else, it always goes at the end of the switch, and Swift won't let you put it anywhere but at the end. The next difference. In Swift, each case must include at least one executable line of code. A comment is not good enough. There must be at least one real statement. And this is different to many C-style languages where it's common to see multiple empty case statements written one after the other where we have what's called fallthrough from one case to the next. And this fallthrough is used as a way to combine multiple cases together. So here, case 1, 2, and 3 all fall through to the code following 3. Case 4, 5, and 6 all fall through to the code after 6. But in Swift, this is not what happens. If you add an empty case expecting to fall through to the next one, you'll get an error. Swift does not automatically fall through in a switch. By default, each case is considered separate, independent, and is expected to contain code to have something to do, to have a reason to exist at all. Because when we hit our switch statement, it'll check each case from the top down, ruling them out one by one. And as soon as any of the cases counts as true, we will run the code within that case, and then we're done. We've ruled out the rest. There's no fall through. We look no further. We'll drop to the end of the switch and move on. But one benefit of Swift automatically treating each branch as self-contained is we don't need a break statement at the end of every case as we do in languages where you actually have to stop yourself from falling through. Now if you do have a case where you want to just do nothing, let's say in my default clause that I had to add here, but I don't want anything here, I don't want a print statement, but we do still need a line of code, so you can write a break statement in Swift, and that would suffice for our syntax. It counts as an executable line of code, but usually you don't need this. It's only in a situation like this where you have to explicitly end a case or if perhaps you had some logic, some branching going on, like an if/else statement inside one of these cases. However, in other languages, one reason we actually make use of fallthrough is so you can list several cases and have them all combine together to do the same thing. But in Swift, we can write one case that checks for multiple values, separating them with commas. So here, one case for 1, 2, or 3, or another for 4, 5, or 6, or the same idea, but with strings instead. However, when you're dealing with numbers in your switch case statements, another option that is the in Swift, we can also provide a range of values to check for. And this is something that isn't possible in the switch syntax of many languages. So if I wanted to test an integer and have a case that sees if it's anywhere between 1 and 10, I could write each value separated by commas like this, but I could also write case 1…10. In Swift, these three dots are what's called the range operator. Whenever you see the three dots, understand you are dealing with a range of values. And to describe a range, we really only need two things: where does the range start and where does the range end. And that's what this syntax does. It's a very concise way to say create a range of values going from whatever is on the left to whatever is on the right and inclusive. So this would describe a range of 1 to 10, including both 1 and 10, or a range starting at 100 and going to 500, again, including the numbers on either side. It's a very easy way to write a case that matches against multiple values if those values are in a range. Now there are two range operators in Swift. This is one of them, the three dots. We will see the other one in a moment. And we use ranges a lot in Swift. Not just in switch statements, they're also incredibly useful when creating loops. Okay, there are a few advanced features of switch statements in Swift where we can take this even further, like using where clauses for pattern matching or creating temporary variables. But this is enough right now, enough to keep us going forward. So to review, switch statements in Swift must be exhaustive and all values handled somewhere in the switch. Each case must contain one executable statement, something to do, and that there's no automatic fallthrough from one case to the next. As soon as we hit a case that's true, we'll execute just the code in that case, and then we're done. We jump out of the switch statement and move on. So let us move on and write a few loops.

Creating Loops and Making Ranges
When we want to repeat a block of code multiple times to create a loop, there are three and only three ways to do this in Swift. We have the classic while loop that you'll find in most C-style languages. While a condition remains true, say while itemsToProcess is greater than 0, we keep repeating whatever code is in the body of the loop. Now in Swift, the differences in syntax here are exactly the same as with the if statement. No parentheses are needed around the condition, but curly braces are always required, and the condition must evaluate to true or false. Now if you know the while loop, you probably also know it's lesser used cousin the do/while loop, where the condition is placed at the end and where the main difference is the code in the body of the loop is always executed at least once. You used to be able to write a do/while in Swift, but it was renamed. If you want this behavior, Swift calls it the repeat/while, and it looks like this. And again, the difference is with a repeat/while, the code inside the curly braces will always run at least once even if the condition is false because it will run it before that condition is evaluated. And once again, parentheses optional, curly braces required. But one thing you might expect Swift to have, and it does not have the very common classic C-style for loop with the three typical pieces of initializer, condition, and afterthought often for incrementing an index placed up at the top. You cannot do this in Swift. If you're someone who experimented with Swift when it first came out, you might be thinking hang on, I'm pretty sure I wrote a basic C-style for loop, and you might have. This format was allowed an earlier versions of Swift. It was removed in Swift 3 because we have a better option: the for in loop. It's more powerful. It's more structured. It's a more Swifty way to make a loop that will just repeat for every item in a sequence. And okay, every item in a sequence might sound kind of vague and nonspecific, and it is, but in a good way, because this covers an incredible range of describing loops from super basic like for every number from one to five, or for every character in a sentence, or for each element in an array, or for each text field in a form, or for each image in a folder of 10, 000 images. Here's the syntax, and to start simple, I've got this array of strings here called bunchOfWords. I'm going to write a for in loop to iterate over each element in this array. So I type for. In Xcode, I start to get code completion. I want to do a Swift for statement, I hit Enter, and it generates the basic structure. The blue placeholders are what I need to replace to make this complete. For each item in items, we will do this code. I'll type word, hit Tab, bunchOfWords, hit Tab again, and just print it out. And the loop is complete, but a quick sidebar. You see, up to now, we've been mainly viewing our results line by line using the results panel in a Swift playground, but when we use loops, that's not going to be enough. One loop might run a thousand times. We can't just expect all the results of that loop to fit in that one tiny spot. So here I'll simply get an indication of how many times this loop executed, which is worthwhile information, and it's showing 6 times, once for each word in the array. But because I'm using a print statement inside the loop, I can see the actual output down in the bottom in what's called the debug area. If you're following along and don't see any output, check two things. One is you can toggle this debug area on and off using the button at the bottom left, or alternatively, you can use a button up at the top right to do the same thing. And this play button next to it controls whether the playground will automatically run or not. And to change that, click and hold over the play button. You get the option to automatically run or to manually run. Now the visual difference is that if the play button is solid blue, it should automatically run. If I've changed that to Manual, I'll see that it's hollow, and I'd need to click it again to rerun this playground. Back to the code. Back to this loop. For those of you most familiar with those classic C-style loops, notice the benefits. I don't have to keep track of an index here. I don't need to ask for the number of elements in this array. I don't have to worry about off-by-one errors. I don't have to care about the array being larger or smaller or even empty. It'll just work. But if you are completely new to this kind of loop, there is a question people usually have. Hey, Simon, I understand where this name comes from, we're looking at the bunchOfWords array, but where did this name come from? And the answer is, of course, that this name is completely up to me because it's only used within this loop. It's a temporary name for each item in whatever sequence of items I am looping around. But I could have called this individualWord, or I could have called this x, or I could have called this, well, whatever you want to call each item as long as I then use that same name within the body of the loop. I'll just undo this and take it back to word because that makes sense for each word in my bunchOfWords array. So first time into the loop, word will be the string mellifluous. Second time into the loop, word is now the string bioluminescent and so on. Okay. But not all of our loops will just iterate over elements in an array, so let's make a for in using a different sequence, a pure sequence of numbers such as 0 through 10. I'm just going to comment this code out right now. I'll highlight the lines and hit Command+forward slash. We just put the two forward slashes at the front. I can do that again. Just hit Command+forward slash to toggle that on or off. Again, do another for statement, hit Enter, and I'll fill this out. I am using the three dots we used in the previous clip on switch statements. Again, this is the range operator. It describes a sequence, a range, beginning with whatever number is on the left side, going up one by one, ending with whatever's on the right, and it's inclusive, what's also called a closed range, so 0 through 10 including 0 and including 10. Now I'm using number to represent each item in the sequence, but again, this is whatever I want to call it. It could be number. It could be eye. It could be index. It could be foo. Whatever I use in the for in statement is what I then need to use in the body of the loop. And to be clear, this name, whatever I choose, is only used within the loop. So once I've finished iterating over this sequence and moved on, it's gone; it's out of scope. If I try to print it out, I get an error. I mentioned in the last clip that there are two options for the Swift range operator. We've seen the three dots, so here's the other one, two dots and a less than sign. This also generates a range, but with one small difference. Whereas the first one is a range that includes both numbers, this two dots and a less than sign will include the one on the left, but go up to one less than the number on the right. Officially, the name for these is that the three dots is the closed range operator and the two dots then less than sign is the half open range operator. And this version of the range operator is useful for things like zero-based collections like arrays where you might want an index going from 0 to 1 less than something, like 1 less than the count of items in an array. But that's it. That's the three loops we have in Swift. We have while, repeat/while, and for in. We'll see more examples of these, but I do have a couple of sidebar moments first, perhaps even been dealing with a few questions that could even now be at the back of your mind.

Sidebar: Taking Longer Strides
A quick sidebar question I sometimes get from folks who are very used to C-style for loops and keeping track of their own indexes is okay, Simon, these range operators are convenient and everything, but all I see are ranges that go up one by one. What if I want something a little different? So to review, this is how we'd write a closed range, an inclusive range going from 0 to 256. It is simple. It's quick. It's easy readable syntax. But to keep the Swift range operators simple and readable, we must embrace two limitations about them. One, the sequence always goes up from smaller to larger. 0…256 is allowed. 250…256 is allowed. But 256…250 is not. They don't go in reverse. Limitation number two is range operators will make a sequence that goes up one by one, step by step if you like, one small step at a time. Because let's face it. That does describe the vast majority of sequences we ever need in programming, one that goes from smaller to larger and increases one by one. But yes, once in a while we will need something different, and when we do, we don't use a range operator. So maybe I want a sequence that will change in increments of 16 or 50 or -5. Instead of one small step at a time, I now want to take longer steps. I want to stride between one value in a sequence and the next value. And that is indeed what we call this. We stride. So I will remove this range, and I'll replace it with the word stride, and we get code completion. There's only two options here I care about, the ones with the f at the start, which means function. Stride is a function. It's a piece of reusable behavior built into Swift, but there are two slightly different versions of it. If I look at the start, I see one says StrideTo, and one says StrideThrough. And the difference here is exactly like the difference in our two range operators. It's whether we want a range that includes the final value we specify or a range that goes up to that value, but does not actually include it. If we StrideTo something, we're going up to that final value, but stopping just short of it. We don't touch it. We don't include it. If we StrideThrough, we are inclusive of the final value. Let me demonstrate. I will choose StrideThrough. I'll pick it, hit Return, and I'm now asked to fill out three placeholders. Before each of the blue placeholders, I'll see the words from, through, and by. If I'd pick the other version of stride, these would've set from, to, and by. And when we call functions in Swift, we often have these parameter names, these labels, to make it very obvious what each piece of data we're passing in represents, and I'll be exploring this a lot in the next module. But for now, I'm going to make a range that goes from 0, Tab, through 256, Tab, by 16. That's everything. We're done. Notice the results from the loop. We're going from 0 to 256, striding by 16 each time, and inclusive of the final value of 256. If I select that, delete it, and then do the StrideTo version, again, 0, Tab, 256, Tab, 16, the difference below us is we won't include the final value, the 256. We're striding up to it, but we don't stride through it, so the last full multiple of 16 here is 240. And we also use stride if we want to range to go in reverse, from larger to smaller. For example, to stride from 100 down to 0 in increments of -5. So we have the Swift range operators that'll work for most of the ranges we ever need, and we have stride for anything more complex. End sidebar. On to the next one.

Sidebar: Using String Interpolation
I admit the code I've written so far has included some pretty boring print statements. Time to take that a little further. Going forward, we'll be using a feature of Swift called string interpolation. And okay, if you haven't done this before, a phrase like string interpolation can sound potentially difficult or technical. It totally isn't. Interpolation is what we do when we have a piece of existing content, even a paragraph or sentence, and we want to shove something new into the middle of it. And it's not some newfangled computing term. Interpolation is a very old word. If I open the dictionary from the 1800s, I could find the word interpolate, and it would tell me that to interpolate is to alter, as a book or manuscript, by insertion of new matter; introduce new words or phrases into. And okay, in programming, we may not be altering a book or a manuscript, but we do often need to customize some text. And this is what it's for, to make a meaningful error dialogue, or construct an email, or save the details of an event or a log file, or pop up a message to say that in the 
(Woman) Blue team, the player 
(Woman) NiNjA-DeAthMaStER was just 
(Woman) sniped by 
(Woman) Grandma_of_5. A combination of fixed text with some variable dynamic data. Now, of course, you can do this in other languages, perhaps using concatenation say here in Java, using the plus operator to concatenate bits of text with other bits of text. And we can do string concatenation like this in Swift. This syntax does work. You can use the plus sign, or you could even use the plus equals sign to add a new piece onto the end an existing string variable. But when you start creating longer strings, concatenation can get kind of ugly. You have to be attentive that all your spaces are in the right places, and also, this is Swift. So if I want to use different data types, anything that isn't a string would need to be explicitly converted into a string before I could concatenate it together with another string. So string interpolation will make this easier and more powerful. And all you have to remember is three letters, well, three symbols, a backslash and a pair of parenthesis. That's it. If you can remember backslash and pair of parenthesis, you're now an expert on string interpolation in Swift. Here's how it works. First, I have in mind some piece of text, some string I want to create and use where I know there will be changeable elements like Now Playing 
(Woman) TRACK-NAME. by 
(Woman) ARTIST-NAME. which is 
(Woman) DURATION long. So when this string is created, I want to replace these three pieces. Over in a Swift playground I have a simple setup here, a few variables I want to include in this longer message, which right now is just a regular string. I'm going to turn off the Automatically Run option here just so we don't continually complain about it while I'm changing things. And at the places in the string where I have my placeholders, I'm going to drop in a set of those backslash pair of parentheses. Then inside each set of parentheses, I write the name of the relevant variable or constant. Click play to run this, I'll set it to Automatically Run, and that's it. That's string interpolation. When this string message is created, whatever is in these variables will be substituted at these places. It's a compact readable syntax to make custom strings, and it stays readable even when making longer strings. Also notice I'm using the integer variable duration here, but I don't need an extra step to convert it because if we're doing string interpolation using these backslash parentheses, then we are telling Swift we're making a string here, so it's going to regard these as an explicit request to convert anything that isn't already a string into a string. Now I'm creating a constant here using let, but I really don't even need this step. I could just take this string literal and paste it inside the print statement, and string interpolation continues to work. I see the output at the bottom. But it gets more powerful because we're not limited to just showing the value of one variable or one constant inside each backslash and pair of parentheses. We can also write an expression here when we do this. For example, right now, duration is showing as number of seconds because that's what I have to work with. But that's not very friendly. I'd like to show minutes and seconds. So first, inside the parentheses where duration is, I'll turn this into an expression to divide duration by 60. Now 60 goes into 228 three and a bit times, but because this is an integer divided by an integer, the result will be another integer, so just 3 ignoring any remainder. But that's okay because I could add another backslash pair of parentheses into this and use duration again. But now I'll use the Swift remainder operator. You might know it as the modulo or modulus, the percent sign, which used this way will divide duration by 60, but not give me the result of 3, but instead whatever is left over, the remainder of 48. I really need to do a couple of finishing touches here. Looks like I've got too many spaces in my string, so I'll just tighten that up. And I'm going to put a small m after the closing parenthesis here and a small s after the second one here, and we have a bit more of a presentable message at the bottom. And that's string interpolation, a very straightforward, very readable format all down to the backslash and pair of parentheses. End sidebar. Let's move on.

Constructing Code: Who Does What? - Creating Functions
Defining and Calling Functions
As in any language, as soon as we write more than a few lines of Swift, we'll want to take our code and start grouping it into small modular reusable pieces, functions, where we take a few lines of code, group it together, and name it, so we can repeatedly call it. If you're coming from a very pure object-oriented background, then right now you're hanging back thinking, I don't really care for functions, I'll wait until he starts talking about methods of a class. Well that moment is right now, because in Swift, the syntax for functions and methods is exactly the same, and what we're about to cover is 100% relevant for when we get into classes. And here is that syntax, the keyword func, f-u-n-c, followed by whatever you want to call your new function. Now when you write function names in Swift, the style guidelines are to capitalize them the same as constants and variables, again, camelCase with a lowercase first letter. But, of course, good function names are going to feel different from constant or variable names, because functions do something, they perform actions, so often it's a verb, connect, append, fetch, join, or a verb/noun combination, showMessage, openFile, validateCredentials and so on. Now right now I'm sure there's a lot of folks thinking, yeah, yeah, yeah, I get it, I do that already, so let me just say this. As you get deeper into Swift, you will start naming functions differently here than how you'd name their equivalent in C# or Java or JavaScript, and I'll talk more about naming at the end of this module. As in other languages, Swift functions can have parameters, Swift functions can return values, they can do both, but let's start simple without either, and then add them. So after the function name I add opening and closing parentheses, and then opening and closing curly braces to contain the code for this function. Now I've pointed out a few places in Swift where parentheses are optional, like around a condition in an if or a while statement, but these parentheses are required, because in a Swift function they have meaning, to be explicit that this function has no parameters when we call it, we won't be passing any data in. I'll drop in some basic code, and our simple function is defined. But, of course, this function won't do anything unless we actually call it, so to call it, I just use the name of the function, I'll let Xcode give me code completion, select it, and hit Return. And, again, empty parentheses used to call it, I am passing in no arguments. And we get our result. Okay, pretty basic stuff so far. So let's add a parameter. I now want this function to accept an integer value when it's called, so inside the empty parentheses I'll write a name for my new parameter, then a colon, and then the type, Int. So we're looking at a type annotation, just like with variables and constants, though here we don't need the word let or var. So the function now takes a single parameter called number of type Int. And inside the body of the function, I'll make that part of the print statement using some string interpolation. However, our call is now broken, as we must now pass in an Int argument when calling this function. A lot of programmers might try this, just typing in some integer literal here, but this is not going to work and gives me an error. Swift syntax, once again, is a little different. But if I click the error symbol in the gutter, I'll get a Fix-it here. It recognizes I'm using C-style syntax for calling the function, and helps me correct this to Swift syntax. So here's the deal. In Swift, by default, whatever name is used for a parameter when a function is defined, is also used again in every single call to that function. So inside the parentheses of a function call, where a lot of languages just have the arguments, the raw data being passed in, in Swift, each argument is paired with a label written before it with a colon. If you have several arguments, they're separated by commas, but each has its own label. Now we saw an example of this in a previous clip with the built-in Swift stride function. It's a function defined with three parameters. So in a lot of languages, stride might have been called like this, three arguments one after the other, but in Swift each argument has its own label. So if you are most familiar with the C-style way of calling it, be patient with yourself if you're programming auto-pilot stumbles on this a few times. And allow Xcode to help you, not with just correcting an error with a Fix-it, but if you let Xcode provide auto-completion for function calls when you're writing code, that you start writing the function name, you use the up/down keys to select it, hit Return, it's going to tell you what those labels need to be and where your arguments go, and then there's nothing that will need fixing. So let's take this one step further, multiple parameters. I now want to pass an integer and a string. It's easy enough to do. Within the parentheses I follow the first parameter with a comma, and once again, its parameter name: parameter type. So my second parameter here is called name of type String, and I could do a third, and a fourth, and so on. And I'll add on to the print statement to prove that this works. Now calling the function, once again, it will be easiest if I just rewrite it and allow Xcode to auto-complete. I start typing the function name, select it, hit Return, get the two argument labels, number and name, with the blue placeholders for the actual arguments themselves. I can use integer and string literal values here. I could, of course, have used constants or variables as long as they're of the right type. A function call is another place where the Swift compiler will do type checking. So these argument labels when calling a Swift function are a difference for a lot of programmers, but here's another very important difference. Understand that any parameter passed into a Swift function is treated as a constant, not a variable, in that function. They are immutable values. So I'm accepting this integer parameter called number into my function here. I can look at it, I can use it and print it out, but I can't change it, and if I try I'm going to get an error. Now I could copy it into a new variable, and then change that variable and work with it, but a normal Swift function parameter is a constant. Okay, I've been talking about normal default behavior of writing Swift functions, calling Swift functions, using parameters. It is true there are some options to change that default behavior, we're going to get into that in a moment, but let's first see how to return values from a function.

Returning Values
A function can also return a value, and in many languages you would write any return type before the function name, but not in Swift. Here the return type comes after the name, and after all your input parameters are defined, and it looks like this. First, we write the return arrow, a hyphen and greater-than sign, written together. A return arrow tells us this function returns something, and then following the arrow is what it returns, the type. So this function returns an Int, or this function returns a Bool, or returns an array of Strings, or returns an optional String, or just a String. And all we need is a type here, we don't put a name for this, because we'll be handing this value back to some other part of our code, and they can call it whatever they want. I really like this format, this sequence of the function name, then parameters, then return type, because I believe it's the way most programmers naturally talk about, and even think about, a function. What's it called, what does it accept, and what does it return? Okay, so there's this function called validateCredentials, it takes two strings and returns a Boolean. That's the way I would describe one, it's good to write it that way. But if we say we are going to return a String, we need to return a String, which is what Xcode is currently complaining about. I'll just return the string constant I'm making on line 4, but it could have been a variable, I could return a string literal, we must have a return statement that matches our return type. And if there's logic within our function, there's loops and conditions and switches, the Swift compiler will make sure there is a return statement in every possible path. Now I could just continue to call the function as before, just using the function name with empty parentheses, as it needs no arguments, and this function is returning a value, I'm just not doing anything with it. So I'll accept that returned value into a new constant, and I won't need a type annotation here, because result will be automatically type inferred as a string, because the return type of our function was String. If the function was defined to return an Int, this would be type-inferred as sn Int. So type inference doesn't just work for creating variables and constants when you have literal values, it works everywhere. So this is how we return a value, that return arrow and return type. If you don't see a return arrow in a function, the function doesn't return anything. This basic format of parentheses, return arrow, return type, is a very important thing to recognize in Swift. Let me take a few minutes on that.

Introducing Function Types
What I'm about show you might at first seem like a bit of Swift trivia, but will be extremely useful. You see, if a Swift function doesn't return anything, you normally just omit the return arrow, but you could also write it this way, and you will occasionally see this, the return arrow with the word void. Now as the C, and Java, and C# folks know, Void is a word we can use to be explicit when a function does not return a value. Void in Swift is written with a uppercase V, because Void is a type like String, and like Int, and in Swift our types begin uppercase. Just in case you're wondering, ah, but didn't we use the word nil for no value, so is nil the same as Void? A good question, but no. If you recall, nil is a word we only use with optionals, when we have an optional String or an optional Int, where a piece of data may or may not have a value. Void is different, it's much simpler. There is no may or may not here. This function does not return a value, ever. To be clear, I am not suggesting that if your functions don't return anything you need to add this return arrow Void, don't do that. In fact, if I was doing a code review and a new programmer had written this, I'd tell them to take it out. Now this is what I meant by it might seem like a trivial point, of, oh hey, you could write this, just don't, because there's more to it. Even though I don't want you to write return arrow Void for your functions, I still want you to know what this means, because knowing it will be useful later, and here's why. As we start to read and write more and more Swift, we will have multiple functions that might not have the same name, but do have the same parameters and return types. For example, imagine you're going through some Swift code and you find several functions that accept one String parameter and return a Boolean. Now those functions could be significantly different, and the function names are different, the parameter names are different, some of them might suppress the argument label with the underscore, some of them don't, and of course their functionality could be wildly different, but still, they are all functions that accept one String and return a Boolean. And in Swift, we say these functions have the same function type, and we can write the function type like this. Rather it's a pair of parentheses containing the parameter types, and then the return arrow, and then the return type. So these functions I showed a moment ago are different, but they all have the function type String, return arrow, Bool, and that's all a function type is, a very basic straightforward summary of the parameters and the return types. We don't care about the function names or the parameter names, there's no code here, and we're not even saying that we think these functions are necessarily all similar, they could be totally different, but still, they do have this in common, they are all a function that takes in a string and returns a Bool. So then, this would be the function type of any function that takes one integer and returns a String, or the function type of any function that takes two doubles and returns an array of Strings. But when we have a function that doesn't return a value, say a function that takes one Int parameter and doesn't return anything, well in the function itself it doesn't need that return arrow Void. If I was asked to write the function type, I would write this. Int in parentheses, return arrow, Void. So this is the function type of a function that takes one Int and returns nothing. We're being explicit with that return arrow Void, because all a function type is is a way to be explicit about the parameters and return types, so it's written out here so there's no room for misunderstanding. And finally, here is the simplest function type for any function that takes no parameters, and returns nothing, empty parentheses, return arrow, Void. If at this point you're thinking, okay, I think I kind of get what a function type is, I'm just not sure what I do with it, that's fine. In fact, that's what I'd expect right now. But if you can recognize that this is a way to describe parameters and return types, and that's all it is, then okay, we're good here. When we get to the very important subject of closures, we will see these again, but we've got a few other things to cover first. The last few minutes has been about functions that return values, and how to be explicit about functions that don't return values, but there is another thing to cover. What happens when a function does return a value, and we don't care.

Correctly Ignoring Return Values
A quick sidebar moment. You see, we can call a function that returns a value, and just ignore the value it returns. It is allowed, but it's still worthy of attention, because the code that calls a function and ignores the return value, looks exactly the same as the code that calls the function and, whoops, doesn't realize there even was a return value. So a line of code like this, that calls a function but ignores any result that it's generating, will work okay in a playground, but when you start to write Swift projects, like an iOS app, or here a MacOS project, the compiler is going to be a little more picky, and writing a line of code that calls a function, but ignores any returned value, will generate a warning. Now it's not an error, because this is technically allowed, but still, by default, a warning, to say, hey, I notice here you're calling a function that returns a value, and you're ignoring that return value. Was this intentional or accidental? Swift likes us to be explicit in all things, and if I do want to ignore that value, there is a best practice. And it's not to assign the result to some pointless dummy constant or variable and then just ignore that, because that would be a different kind of warning when Swift realizes you've made something that's never been used. Now, instead of assigning to a variable or constant, we assign to the underscore. Now this says, I realize this function returns a value. I don't need it, so I'm explicitly ignoring it, and the warning goes away. And now any other Swift programmer could read this line and say, okay, we're intentionally ignoring a return value here. So when you see this underscore used in Swift, it is a way to intentionally ignore or suppress something. And it doesn't just apply here. The underscore comes in useful in a couple of other places with functions, so let's see those.

Customizing Argument Labels
To review, in Swift, when a function is defined with one or more parameters, the parameter names aren't just used within that function, they're also used in every single call to that function, to label every argument as it's passed in. That's the default behavior, and it's what we'll use most of the time. Can it be changed? Yes, in two ways. One, we can make it so a label is not required on an argument when calling a function, or two, we can change it so we can use a different name outside the function from the name we use inside it. So first, how to remove it. Let's say I have a function called showMessage that accepts one String parameter. A parameter needs a name, we have to call it something, so we have the usual parameter name, colon, parameter type. To call this, right now I'd need the following code, function name, argument label, and argument. But showMessage message: does indeed seem a little redundant. I can argue if a function was called showMessage and takes one String, it's probably not a great leap to figure out what that string represents. So to remove the need to write this label, I can go into the function definition, and before the parameter name put an underscore, and importantly, there is a space between the underscore and the parameter name. Now I mentioned in the last clip, when you see an underscore in Swift, it is typically being used to intentionally ignore or omit something. Now to be clear, the underscore does not make the argument label optional when we're calling the function, it changes the definition so I cannot use the argument label when calling the function, so now I need to change the call so that it's just passing this argument data with no label. And if you have a function defined with multiple parameters, you can put the underscore in front of just one of them, and remove the requirement for that label, or you could put it in front of any of them, or even all of them, and be able to call that function without using any labels at all. If you're coming from a C-style language, this might be more of what you're used to, but it's not typical Swift style. Here, we like our argument labels. Now you might think, but Simon, aren't these a bit verbose? Isn't Swift all about removing bits of syntax where possible? Why don't we just write every function parameter with a leading underscore so we don't need labels? But Swift isn't about removing things for the sake of removing them. Swift is about clarity, and with any function, there will be more code that uses that function to call it than there is to define it. That's kind of the point of a function, we define it once, so we can call it more than once. So if there is a place you want additional clarity, it's when you call a function, and that's what this adds. Because in many languages, when you read code it's full of functions or method calls that look like this. Okay, we might understand the syntax, but just reading the code won't help me understand what's the first Boolean for, what about the second one? Now you compare that to a Swift call, yes, it's a little bit longer, but it's much easier to understand the role of each argument, and I have yet to meet a programmer who, after a few weeks with Swift, wishes to go back to unlabeled arguments. So this leads us to the next customization. While sometimes we want to remove the label, it can also be convenient to use a different name when calling the function than the name we use within the function itself. An example. Here I have a basic function called calculateDifference. It takes two integers, firstAmount and secondAmount, figures out which one is higher, and returns the difference between them. So right now to call it, I am using those argument labels that are the same as the parameter names. They're accurate, but they're not very friendly. Now we saw that to omit a particular label we can put an underscore before the parameter name. Well, instead of putting an underscore there, I'm going to write a completely different name, from. And now I have two names for this first integer, for this piece of data. The first name is what's used outside the function as an argument label, and the second is what's used inside the function. So I'll add another one before the second parameter, called secondAmount, I'll write, to. So when we have parameters you'll always see a name and a type. If it's one name, it's the name used both inside and outside the function, but if you see two names for a parameter, the first one is the external name followed by the internal name, or more formally, the first one is the argument label used outside the function when calling it, and then the parameter name used inside the function. But back to our code, now I will need to change the call. Instead of using firstAmount and secondAmount, I can use from and to, and I think from and to are a bit of an improvement, but I'm going to try an alternative. Now one benefit is I can change these without touching any code inside the function. And, in fact, to make this a bit more readable and Swifty, I'm going to shorten the function name to just call it difference. This function has no side effects and just returns a simple single value so a noun is fine. There are a few languages where the style is to always have a verb, even having something like get, so get difference, or calculate difference, but we don't tend to do that in the Apple world, and this makes a entirely readable function call, that this result will be assigned the difference between this number and that number. And the thing is, being able to choose different labels for your arguments can make it much more readable to call a function, but importantly, I wouldn't have wanted to use these names, the between, and and, as the actual parameter names inside the function, because then I'd need code here saying, if between is greater than and, return between -- and, otherwise, return and -- between. No, it's much better to use names like firstAmount and secondAmount within the function, with between and and outside it. Now sometimes your parameter names will be perfectly acceptable as argument labels, but it's good to have the option.

Naming Functions in Swift
As you write and read more and more Swift, you're going to start thinking of functions, and methods, when we get to those, as not only the first part of the function name, but that function name together with the argument labels, because that leads us to naming things slightly differently here. Back to that example of a function with a pretty typical verb/noun format, showMessage, with a single String parameter. Now that parameter needs a name, I'll call it message, but it does make this call feel redundant, showMessage message. In a previous clip, I showed how to suppress this label, but there is another approach I could take, to change the function itself to just show, and have a first argument label of message, because after all, we're going to see it all. So you'll see this kind of naming in Swift a lot, where a function name that, in another language might be written as one whole piece, is actually broken into multiple pieces. And one of the best ways to get a sense of these naming conventions is to pay attention to how some of the built-in Swift functions are named. And we've already seen examples of this. The very first Swift function I demonstrated in the course was a built-in function to get the type of a variable or constant, and the equivalent function exists in other language, and is often called typeof, all one word. And sure, this function could have been called typeof in Swift, but instead, here the function name is type, with the first argument, of. It's a small difference, but it's a worthwhile one. After all, this is two words, it's a noun and a preposition. This function is actually returning the noun. The function returns the type, and the parameter is the of. Another example is when I showed the stride function, that there were two versions of that, StrideThrough and StrideTo. Now this could have easily been done with two different function names strideThrough and strideTo, but in Swift the function names are the same, and the number of parameters is the same, and the parameter types are the same. The only difference is a different argument label. Instead of calling stride with the arguments from, through and by, we call stride with the arguments from, to, and by. And these things are worth noticing. Naming things well in Swift means you stop thinking about a function call as one good name that's followed by a bunch of arguments tacked onto the end of it, you think about what the entire call is going to look like. But okay, we've gone through a lot in the last few clips, and there are some deeper things we can do with functions and parameters, but what we really need first is to have some more complex data in our programs, and that's in the next module.

Taking Data Types Further: When to Limit, Describe, and Collect
Using Enumerations
We've been working with basic pieces of data, Ints and Strings, and Doubles, and Bools. In this module, we're going to take things further, and we can go in two directions with that. One way is to start gathering multiple pieces of data together into dictionaries, or tuples, or structures, and we'll see how to choose between them, but we're going to begin smaller with the idea that often there's a single piece of data that we're dealing with, a single constant or variable, but it's not an Int, and it's not a String, and it's not a Bool, or a Double, or a Char, or any other type that Swift provides. Sometimes it's going to be up to us, where we define our own data type. Now there are several ways of defining our own types. We'll begin with enumerations. And, okay, once again, you will find enumerations in many languages, but once again, a little different here. And if you're not that familiar with enumerations, let me take a moment to unwrap this idea. Say I've decided to write an app for people to track their media consumption, the books they read, and the movies they watch, and the music they listen to. So for each item we'll store the name of it, and the year of release, and I also want a variable to store the type of media, is it a book or a movie, or music. Now I could define this variable as being of type String, and Swift would make sure it's always a string. But, just because it's a string doesn't mean it will actually contain something useful within my program. It might say the word book, or movie, but there's nothing that would stop it being set to the word Quokka, or to a URL, or to have the content be the first page of Moby Dick, it would all compile just fine. This variable is a little too flexible. I suppose I could define it as an Integer, and just add a comment that in this application, 0 means book, and 1 means movie, and 2 means music, but a standard Int has a range of 2 to the power of 64 minus 1, or several bajillion, kazillion, so this variable might be 0 or 1 or 2, but it could also be 7 or -36, or 374 million, it's all allowed as far as Swift is concerned. So we would like a piece of data that's more controlled, that's limited to a specific set of possible options, and this is what enumerations, or enums, allow us to do. Where there might be two options, or three, or seven or twelve, but probably not hundreds or thousands, because we have to write in our code what all these different options are. For those of you who aren't used to defining your own types, there is a mental shift in gear you need to make the first couple of times you do this to get clear on the concept here, because we've made dozens of variables and constants, and we may have chosen between different data types, but somebody else already defined those types. The rules of what it means to be of type String, or of type Int, or of type Bool, they're already baked in to the Swift language. That if you create a variable of type Bool, that variable is allowed to be true or false, and nothing else. We're not doing that, we want to say, if you create a variable of our new type, let's call it MediaType, that variable will be allowed to be a book, or music, or a movie, we may have a couple of other options like game or documentary, but once we've done that, once we've defined the type, then we can make a variable or constant of our new type. To define a new enumeration, and the possible values for it, it's the keyword enum, the name of our new type, and then a code block. Now the style guideline is an uppercase first letter here, because we're making a new data type, not a new variable or constant, and this is Swift, data types begin uppercase. I'll call this MediaType, so we'll soon been able to create variables and constants of type MediaType, just like creating variables or constants of type Int or of type String. And inside the body of the enum, I then list the options I want, and we use our own words here, whatever is meaningful for us. Now in Swift, each one of these is called an enumeration case, a little similar to a case in a switch statement, but here we don't need a colon, because we're not following these with code, we're just listing our options one after the other. Now the type name itself should be written upper CamelCase, but each option within that type, lower camelCase. I can write them all on separate lines, or alternatively, I can write several on one line using a single case keyword, and just separate each of the options with commas. Now personally I prefer separate lines, but as long as it stays readable, whatever works. There is no practical limit. If I wanted to write out a hundred or a thousand different cases here, I could, but just remember that however many options that you define here, you will later be choosing one of those options. Now once that's done, we can start to use this new enum MediaType, as a data type, and as we start typing, it should actually appear as one of the options here, so itemType: and I've got MediaType, so I'm just using the standard type annotation. This variable, itemType, now has a type, it doesn't have a value yet, and the way we set the value here is to use the name of our new type, MediaType, with .syntax. So notice, after the dot, I get the code completion options. So within our code, this new variable is restricted to only those options we've defined in the enum. I can set it to MediaType.book, and because I defined this as a var, I could change it later on. But here is something important to recognize, because you'll see it many, many times, when a variable is defined of an enumeration type, like this one is, there's also a shorthand we can use to work with the values. So because this variable has been defined to be of type MediaType, and Swift knows that's an enumeration, I now don't need to write out the complete name all the time. I can assign a value, just by using the dot, so .movie, or .book, or .game. And as you see, it's smart enough to give me the options that are available, without me using the word MediaType. And here's the thing. Even if you never defined any of your own enums, you need to recognize this dot something syntax, with nothing before the dot, because you see it a lot in Swift. When programming iOS or MacOS, there are many places where Apple has said, okay, if you want to control this thing, you're going to use an enum to do it. For example, I'll jump over here to an iOS project I have. There's some code here to customize a text field. Now the text field in iOS is very powerful. It has things like auto correction options, and capitalization options, So Apple have defined enums to control many of these, and we use the dot syntax here for them. If I want to work with capitalization, my options are to capitalize all characters, to capitalize sentences, words, or just none. If I want to affect what's shown on the return key on the virtual keyboard for this text field, I can't just set it to whatever I want, I can only choose from the list of options that Apple has provided, another enum that they've already defined. So back to our own enum. A great benefit of using an enumeration type is it's then very straightforward to use this with a switch statement, because Swift will understand all the possible cases this variable could be. And because Swift sees that I'm switching on something of type MediaType, I can use that .movie, .music, .book, .game format. And any switch statement has to be exhaustive in Swift, but the compiler recognizes here that I am being exhaustive, that there are four possible options for this, I checked them all, so I don't need a default case at the end of the switch. And that is a great thing, not having this default, this catchall place at the end. Because if I later change the definition of the enum to add a new case, the Swift compiler is now going to throw an error from my switch statement pointing out that it is no longer exhaustive, and in a larger program this is a really good thing to be informed about. So I can go ahead and fix it, and make sure that this switch is now an exhaustive one. But enums in Swift can go deeper than this. While a normal enum is just a list, say, an enumeration of champagne bottle names, we can make each case of this enum have an additional value stored with it. You do this by following the enum with a type name. Now that could be a String value, it could be an Integer, or a floating point type, and then each case can have its own specific value, in this case, a string listing the capacity for this bottle, and these are known as raw values. When I then create a variable of that enum type and provide a value for it, in this case the .jeroboam, I can then use that variable as normal, and ask for its value, which is jeroboam, but I could also ask for its .rawValue to automatically get to that string value that's sorted for this enumeration case. So these are raw values, a specific predefined value stored alongside each case. But we can also have additional customizable values that can even be different for every single case of an enumeration, and we call these associated values. Here's what I mean. For our example of MediaType, with movie, music, and book, imagine that for each of these enumeration cases I wanted to store something extra, that if an enum will be .movie, I'd like to also store a string with the movie genre. But if it was .music, I'd like to store an integer with the beats per minute. If it's a book, a string with the author name. So unlike using raw values, where we'd name one type for the entire enum, here we provide a type for each case, and it can be different for each one. And unlike raw values, here I don't know what these values are in advance, I just say what else I would want this enumeration case to store. But when you do this, it means that when you create a variable of this type, you don't just use the enum value of .movie, or .music, or .book, you must then also provide the additional associated value, which for .movie would be a String, or for .music enum would be an Integer. And the way you can then get to these associated values is that in a switch statement, where you'd normally just list the different cases for each enum option, you can follow them with the parentheses and the words let, like let genre, or let bpm, and that gives a name here for each associated value, which you could then use within the body of the switch case. But beyond raw values, and these associated values, you can even add functionality to an enum, with properties and methods. But, a lot of the time, what we've covered in the first part here is what you need, simply using an enumeration to provide a specific set of options.

Defining and Using Structs
We're now going to use structures, or structs, as a way of defining a new type, but there's something I need to mention, because if you're coming from a language where structs exist, but if you think about them at all you think of them as kind of a basic, almost old-school solution, just a simple container, that is not true here. Structures are very powerful, and incredibly important in Swift, and we've been using them all along. The data types we've used so far Int, String, Double, Float, Bool, they are all implemented as structures here. And if you're coming from an object-oriented programming language, I sympathize if you've been assuming that String, for example, is probably a class, and we've been making objects of that class. No, in Swift, String is a struct, and in Swift, structures and classes are very similar in their capabilities, not entirely identical, but pretty close in what they can do. They are more powerful and capable here than in most languages. The basic idea, and a good place to start, is we identify some pieces of data that really belong together, and we define a struct as a simple way to give that data a structure, that we're defining a new type that itself contains other types. So it's the word struct, followed by our name for our new structure. Again, when defining a struct, we're defining a new type, so the name should be upper CamelCase. And inside the body of this struct, we describe the data that we want it to contain. Now we can define either variables or constants here, just using var or let, it's the same syntax we've already been using, and the same rules as anywhere else. And when variables and constants are defined inside a struct, we say they are properties of that struct. Now as with any variable or constant, I can either provide an initial value here, and it will do type inference, but if I don't, we must have a type annotation, which is what I've done for all of these. Now that it's defined, I can create a new variable of type Movie. I could just declare it here, using type annotation, but like anything else, if I just did it this way, there's no actual value for this variable yet. So to create this as a struct, I can set it to equals, the name of the new type, which is Movie, then open parentheses. And you notice that the only option I have here looks like a method call with several parameters to it, and it kind of is, because Swift has looked at my struct definition, and has generated an initializer method, what's officially called a memberwise initializer, to make sure that when I create something of this type I initialize all these internal member values, so I have to provide values for everything here. I can't create it and then fill in the values later, I have to do it all now, because this is Swift, we're type safe, we can't have anything existing in some partially completed state. Now if I had provided initial values within this struct for all of these properties, those would have been used as default values, and I wouldn't have needed to do this. And, of course, the benefit of having a new type to find, is that we can then create many variables of that type. And we use the word instance for our created structs here. So these are two separate instances of type Movie, and they're completely independent of each other. I can use their names, and then use dot syntax to access their individual properties like title, or I can use the same dot syntax to directly access one of them, like the release year, which is currently wrong, it should be 2016, because these properties of the struct have been defined as vars, so I'm allowed to change them. Now, so far this is a generally similar concept to structs in several languages, but in Swift we can also add behavior to this struct, to add functionality, which is not always possible. So I'll write a Swift function declaration inside this struct. There is no special syntax here, it looks like a normal Swift function we've already seen, but as it's been written inside the struct, we say that it's a method of the struct. In Swift, there is no special, unique syntax for properties and methods. If a variable or constant has been written inside a struct, we'll call it a property. If a function has been written inside a struct, we'll call it a method, and this terminology of properties and methods applies if you write these things inside a struct, if you write them inside a class, if you write them inside an enum. I'll now add some functionality to this method. So we're going to return a string and do some string interpolation to use some of these properties of this struct, and I'll go ahead and call this method using dot syntax, using the variable first and calling its summary method, then using the variable second and calling its summary method. So for those of you coming from an object-oriented background, you can see that there are similarities here. We can have properties and methods and initializers, but there are differences. One is that structs cannot take part in inheritance, so I can't define one struct that inherits from another struct. But the most basic difference in Swift is that structures are value types, where classes are reference types. Now depending on your language background, that concept may be second nature to you, or kind of hidden behind the scenes, and we're going to get more into that in the next module. But because what we've just covered here will apply with classes as well, the reverse is also true. So later, we are going to see a few more advanced features, things like computed properties and lazy properties, that will also apply to structs.

Working with Dictionaries
Earlier in the course, we saw the basic Swift array, and it's now time to jump into one of the other two collections built into the Swift language, dictionaries. What Swift calls a dictionary is a common data structure, but it's sometimes known by other names, so you might know it using the term associative array, or map, or maybe even dictionary, Swift isn't the only language that calls this a dictionary. But to review, a standard array contains multiple elements, and where you access each element using a zero-based index. We can change and affect the items here, but the index itself is not under our direct control, it is just what it is, a sequence always beginning at 0, and always going up one by one with no gaps. Now a dictionary also contains multiple values, but each one is accessed with a unique key, and the key is up to us. So it's multiple key and value pairs that are always kept together, and whereas with an array we often don't really care that much about the index, other than using it as a way to get to each element, when we have a dictionary, both the key and the value are often important in our program. An example, airline codes as keys with their full names as values, or maybe employee numbers as keys with their employee names as values. And where an array index is always in sequence, when we have a dictionary, the keys don't need to be in any kind of sequence, as long as they are unique. We can't have duplicate keys in the dictionary. Duplicate values are allowed, duplicate keys are not. So we might have two employees, both called Bob Jones, but we shouldn't have two employee IDs that are the same, the keys have to be unique. Now dictionaries in Swift are strongly typed, and it's two types, not one. It's one type for your keys, and another type for the values. So we can have a dictionary where all the keys are integers, and all the values are strings. Or a dictionary where all the keys are strings, and all the values are also strings. Or you might have a dictionary where all the keys are integers and the values are movie structs. But the point is, you always have to know, what am I going to use to access that dictionary, and what do I expect to get out of it. To create a simple dictionary, we can use a dictionary literal format. This is similar to an array literal, in that we're using square brackets with multiple values inside it, and I can split this over several lines to make it more readable. But everything here is in pairs, multiple sets of key: value, key: value. In this example, everything is a string, so Swift will type infer this as a dictionary where the keys are strings and the values are also strings. If I wanted to declare a dictionary without any values, and then later start adding to it, I would need to use a type annotation, and a type annotation for a dictionary uses two types, the type of the keys and then a colon, then the type of the values. So to declare a dictionary of String keys and String values, it would be String: String, inside square brackets. Well for integer keys and string values, Int: String inside square brackets. But for the moment, the only dictionary I have that has anything in it is this Airlines one. So once you have a dictionary to start using them, we use the square brackets with the key to get to any one key or value pair. So here I'm going to try and look up the airlines dictionary using the key SWA, and pull a string out of it. But there's an important thing going on here, because whenever I request a value from a dictionary, I don't know for sure that I'm going to get a result. Maybe that key exists in the dictionary, and maybe it doesn't, so what is returned from this call, will be an optional string. Swift does know that the type of the dictionary is String, so if I get anything from it it'll be a String, but we can assume that any lookup might not find a matching key, so you always get an optional value that allows for nil whenever you request something from a dictionary. So I can use that if let format we've already seen when dealing with these, to make sure that if I look something up and get a result, treat that as an unwrapped optional, but if I look something up and that key doesn't exist in the dictionary, we can print out No match found. I can also use the square brackets to either change or add a new value. So here I'm trying to see if there's anything with the key DVA in this dictionary. If that key already existed, this line would change the value for it, but if it doesn't exist, it will add this as a new key value pair. Now because I am in a playground, if I just type the name of the dictionary here, over on the right-hand side I can click the eyeball icon, the Quick Look, and I'll get a pop-up showing me all the options that are in here now. They won't always fit, so you can scroll up and down to see them. Alternatively, you can hit the Show Result button, and that will put them in line in your code. Notice that the entries I'm seeing for this dictionary don't match how I entered them to begin with, and that's because a dictionary is an unordered collection. You can always guarantee that the right keys and values will stay together, and you can always search a dictionary for a particular key, but you don't have any control about how those entries are actually stored inside the computer memory. And the easiest way to remove a key value pair from a dictionary is to use this subscript syntax using a particular key, and set its value to nil. Now importantly, setting this key, BHA, which a moment ago does exist in the dictionary, and setting the value to nil, doesn't just remove the value, it removes the entire key value pair from the dictionary. If I type the name of the dictionary again and use Quick Look, we can see it's completely gone. Now, one of the most common things that you'll ever want to do with dictionaries is just iterate around the entire thing, and we can use the Swift for in loop to loop through every key value pair in the dictionary, a very simple syntax to be able to do this, but two important things from it. One, again, dictionaries are unordered, so when you iterate around a dictionary, you can't guarantee how you'll go around the entries. The way they're coming out has nothing to do with the way we put them in. But also realize, each entry in the dictionary, each time around the loop, what we have here, and I've just called each element entry, but I could have used whatever name I wanted, that contains both the key and the value. But what if I was only interested in the value, or only interested in the key? Where I have the word entry, I'm going to change that to parentheses, and just write key, value. Now these names here are my choice. I've written key, value, but it could have been perhaps, code, airline, as long as the names that I choose in my for statement are also what I use in the body of the loop. So Swift here is recognizing that I'm iterating around a dictionary, and it realizes, okay, this is going to be whatever I want to call the key, and this is going to be whatever I want to call the value. But this innocent-looking piece of syntax here, just two names enclosed in parentheses, is worth talking about, because this is something that doesn't have a direct equivalent in many programming languages, It's called a tuple, or tuple.

Creating and Decomposing Tuples
A tuple in Swift is a very quick, very simple way to group a few values together, maybe just two or three things, and treat them as a single item without having to define a struct or class, or put them in an array or dictionary, or any other kind of formal data structure. Now you may here this word pronounced as tuple, or tuple, or even tuple. The word itself is from the same origin as using the word quintuple to mean five things or sextuple for six things, septuple, octuple. It means, several elements gathered together, and that's all it means. It is a simple idea, and it's simple in Swift as well. To make one, you just gather a few values and put them in parentheses separated by commas. That's kind of it. In a playground here I have some constants and variables that are a mix of different data types, I can make a tuple very, very simply, just a pair of parentheses with a few values inside it separated by commas. So this variable, basic tuple, is a single compound value that contains these three things. Now we can group some variables, we can group constants, we can group literal values, we can do a complete mixture. It can be integers, and strings, and bools, and whatever you need. Now most of the time you won't actually even need to make a tuple variable and give it a name like I've done here, you'll just use these parentheses to group a few values together when it's useful to do so. But the question is, why? Well, here's one of the most common reasons. When defining functions, we've seen how to return a single value, like just a String, but if I wanted this function to return multiple values, say, a String and an Integer, well, then the simplest way to do it is to change this function to return a tuple. So after the normal return arrow, instead of just String, I'll add the parentheses and have the String, Int to say this function will return a tuple that contains a String and an Int, but if I say that's what this function returns, then I better actually return a string and an Int. And when you're returning a tuple from a function, you can return any types you want, and any number of them, but you do need to say what types are going to be in that tuple being returned, and what order they'll be in, in this case, String, then Int, simply so that anyone calling this function will know what they're going to get back out of it. So now on line 12 when I'm calling this function, the result I'll get is no longer a String, it's a tuple that will contain a String and an Integer. And that's okay, but what I'll probably want to do is get inside that tuple and get directly to the individual values, what we call decomposing the tuple, and there's a couple of ways to do this. First is that I can use an index number. You can think of a tuple as a really, really simple array here with the first element as 0. So what I can do after the tuple name, which is result, I can just have .0, which is going to be a String which is the title, or .1 which is going to be an integer, the duration, and this works, but it's a bit clunky. So a friendlier option is that in the function definition I can actually provide a name for each part of this tuple. We don't usually provide a name for our return values, but in a tuple it can be useful. We use that standard format of name: type, but the names here don't have to have anything to do with what I've been using in the function itself. All they're being used for is when this is being passed back. Now where I've called this function and received the tuple, I can use the dot syntax to actually access those names, albumTitle, which again is a String, or .length, which is an Integer. But there's an even simpler way to deal with tuples that you receive from a function call. We can use that tuple syntax of the parentheses and the commas to just decompose it, immediately breaking it apart as I'm calling the function, and this is simpler than it might sound. So rather than doing this in multiple steps, first getting the tuple back with a name, and then using that to break it apart into separate pieces, I can just write this. Using the parentheses, it's telling Swift now I know I'm getting a tuple back from this function, and I don't actually want a name for the tuple itself, but I'd like to use these two names for the two elements I know are inside that tuple. Now the names here are my choice, and they actually don't have to match the function definition. The function will return a tuple with a String and an Int, and I can now immediately use those two returned values. Now another common use for tuples is when we're working with dictionaries, because when we loop around a dictionary, as I showed in the last clip, what we'll get from that dictionary each time around is a tuple, it's a compound item containing both the key and the value for each entry. So in this code I'm using this tuple syntax, calling it whatever I want, I'll just say first is key, second is value, names, which I can then use for the key and the value inside the body of the loop. And, again, these names are completely up to me. If I just wanted to use x and y, x will be the key, y will be the value. So tuples are very easy to make, very easy to group things together, and easy to break them apart. Now they aren't intended to replace more formal data structures, and if you find yourself grouping the same pieces of data together the same way, in several places in your application, that's probably a clue you should be looking at something more formal, like a structure or a class. And it's about time we started talking about classes.

Making Sense of Closures
Making Sense of Closures: Why You Use Them
I would now like to introduce you to closures, but I'm going to take a moment to set this up well before we jump into the code because in my experience this is an area, maybe even the area, where programmers new to Swift run into issues. And it's not really about difficulty. It's more that people don't quite get closures the first time they read or hear about them. They don't quite get the syntax of them, and they don't quite get the point of them, and part of that is because the learning curve for closures is an unusual one. Here's what I mean. Most of the time in programming when you learn a new feature or piece of syntax it's a steady learning curve of difficulty over time. You can start with one or two basic facts and actually do something relevant with just that knowledge. You make it work, and then you add onto it one step at a time, gradually learning more, going deeper. So, if you're learning about strings, start by learning how to make a string. Then change a string. Then learn how to concatenate a string. Then use string interpolation. Then learn how to split longer strings into arrays of words. Later you might go deeper into Unicode or work with larger amounts of text. Even later, you may choose to explore localization or extended graphing clusters. The learning curve is gradual. It just keeps on going on a gentle upward slope. There is a lot you could eventually learn about strings. They can get complex. You just don't need to know it all at the beginning. You can still do useful things if you only know a few things about them. It's the same with functions. Begin, you make a simple function. Then make a function that takes a parameter. Then make a function that returns a value. Then use different argument labels. Then make it return a tuple. You can learn a dozen different things about them, but each step of the way continues to be useful. Now, closures on the other hand, there's really not that much to learn, maybe only four or five things to really understand. But you kind of have to understand all those things right away because unlike strings and functions, there's not much you can do with closures if you only know one or two things about their syntax. So what we have is a steeper learning curve right at the beginning. But here's the good thing. Once you're over that initial hump, that's kind of it. The learning curve then really flattens out. There's not much more to learn about closures. There's a couple of advanced options, but really we just need to get over that first bit. So I will do my best to flatten the learning curve out. But just expect that as we're going through this, when we are covering say the first one or two pieces, if you're sitting there thinking I don't see how knowing this is all that useful, you're right, it's not. We're going to need to get all the pieces in place for this syntax to make sense, and then closures just don't become useful, they become incredibly useful. There are tasks that are so much easier and so much quicker in Swift when you're comfortable with closures, and they are used everywhere from general programming stuff like sorting and filtering and working with collections, with particular tasks like animation or fetching data, to the very specific questions like in an iOS app, what's the best way to pop up an alert window? So I'm not going to just quickly blow through this and throw a bunch of syntax at you. We are going to take a few clips on closures. It's that important. So let us deal with the key question. What exactly is a closure? Here's my informal description. A closure will let us take a few lines of code and group it together so we can use it somewhere else in our program. Okay, I'm going to say that again. A closure lets us take a few lines of code and group it together so we can use it somewhere else in our program. If I gave you a moment to contemplate that description, first you might think okay and then think but isn't that a function? I mean a function lets us take a few lines of code, group it together so we can use it somewhere else in our program. And yes, it is. In Swift, a function is a type of closure, so hey, technically we have been working with closures already. But okay, there is a difference in what we mean when we use those words because a function is where we take some code, group it together inside curly braces, and give that block of code a specific name, and later we will use that name to say now go execute what's in that block of code. But the more general idea of a closure, it is still a block of code, it is still written with opening and closing curly braces, but it doesn't have a name, and it doesn't need a name because we're going to use it a little differently. And I will summarize that difference as you write a function because you have a block of code you want to call. You write a closure because you have a block of code you want to pass. You're writing that code so you can hand it over to some other part of the application. Now, that other part might be something you or a colleague wrote, but most of the time it's going to be something already built into the Swift standard library or built into the Apple frameworks for writing iOS or macOS or tvOS or watchOS apps. Some piece of functionality you want to call, you want to use it, but when you call it, it expects you to provide a closure. It wants you to provide a few lines of custom code. So in exactly the same way that we call some functions by passing in an integer argument or other functions by passing in a string argument or a Boolean or an array, other functions can be defined to accept a closure argument, that instead of passing an int or a string, we can write a few lines of code and pass that code in. And whatever we pass it to, that's going to take care of running that code, and it's how we can tap into a tremendous amount of prewritten provided functionality that just works and also have this custom behavior that's unique to us, unique to our own applications. But this idea isn't only in Swift. Several other languages have a similar feature. It might be called blocks or lambdas or function literals or anonymous functions. They're not entirely identical, but the concept is similar enough. But anyway, how do we actually get started? Well, as a Swift programmer, most of the time you're going to want to use closures when you find some piece of built-in functionality you want to use. You read up on how to call it, and you see that it wants a closure. Let's see an example.

Exploring Closure Scenarios: What They Are, and Where You Use Them
So here's my setup, which right now involves no closures at all. I'm just starting some code to track an inventory of books, but this could be anything where I want multiple instances of some custom data structure, books, employees, players, stock items. I have a basic struct here, title, first name, last name, reading age, page count. Below that, some code to create several instances of that book struct and then load them into an array. I have five here, but this could just as easily be 500 or 5000, and they're in the array in no particular order. The problem is what happens now? What happens when I want to start working with these books? Maybe I just want to print out all these books sorted in alphabetical order by last name ascending, or maybe all the books, but sorted in order of page count or sorted by reading age. Or maybe I want all of those things one after the other. In I'm talking of reading age, I might sometimes want to just get to just the books for the under 10s, or just the books for the 10 and overs, or just the books with more than 100 pages. Now if your mind goes to, well, I suppose I could write a for in loop. I could check the age. Well, yeah you could. Some things here would be easier than others, but I suggest you don't want to be spending your time writing your own sorting algorithms. So you might then wonder does a Swift array have the ability to sort? Well, yes, but. I mean it knows how to sort things like an array of integers or an array of strings. It doesn't know how to sort books, and particularly when I want to sort these books in several different ways one after the other. But still, I should go look to see what the array can do. I should look in the documentation for it. In Xcode, I go up to the Help menu and select Developer Documentation and type array. I check at the top to make sure that we're getting the results for Swift and not for any other language, and the one that I want is the array definition in the Swift standard library, so I'll click that to open. To give us more room, I'll toggle off the left-hand side panel here. And first, there's an overview of basic array features, creating arrays, how to access elements, how to add and remove elements. But below the Overview, instead of just a laundry list of properties and methods, the documentation starts to go deeper into individual topics of creating an array, of inspecting an array, getting things like the count of the number of elements in there or a Boolean property for whether it's empty or not. And below that, various ways to access items in the array, add elements to it, how to combine elements, how to remove elements, ways to find elements in an array like the contains method. And again, in Swift, methods are just functions that belong to a structure or class, and I could click through to any of these with a page with more details. But there's also methods like this, the contains method with one argument labeled where. But the type of this argument is not int or string or even element. It's parentheses Element, return arrow, Bool. And this is what it looks like when a method accepts a closure, when we're expected to not just to pass some data into this method, but to actually pass some code into this. And to read this, cast your mind back to module four when we were going over functions. I took a few minutes to introduce the idea of function types, that in Swift when you have a block of code like a function, you can summarize its parameters and return types using this syntax. So if you had several different functions that each took a string argument and returned a Bool, the function type for all of them is the same, String in parentheses, return arrow, Bool. It's a block of code that takes a string and returns a Bool. Or this would be the function type for a block of code that takes an integer and returns a string, and this would be the function type for a block of code that takes two doubles and returns an array of strings. And that's what we're seeing now here in the documentation, that some of these methods, these functions, are defined quite simply. They take an Element, which in this case is a book, and return a Bool. Other ones look a little more complex. This contains where method does return a Bool. We see return arrow Bool at the end. But instead of just passing in one bit of data, I will be expected to pass in a closure, a block of code that itself takes one argument of type Element, which for this array means of type Book, and that code will also return a Bool because a closure is just a block of code. Like a function, it can be written to take parameters and/or return values. But Simon, you wonder, how do I know what to write in the closure? What should that block of code do? Well, when something is defined to take a closure, they're going to tell you what that closure needs to do. Let's see an example by using a closure to sort this array. So in the array documentation, there is a section here on reordering the elements in an array with options to sort and reverse and shuffle, and I have several array methods with the word sort and sorted. The difference between the sort method and the sorted method is that to sort an array will affect the original array and sort it in place, rearranging the elements inside it, whereas the sorted method doesn't affect the original array. It will return a new sorted copy of that array. Now my original array is defined as a constant, I used the word let, so I can't rearrange it in place. The method I want is this one, the sorted by. It will return an array of Element, for us, an array of books, but as input, this method expects a closure to describe how I want to sort, and the closure needs to take two arguments, Element, Element, which for us is Book, Book, and return a Bool of true or false. Now if you're thinking I still don't get it. If I have to provide my own code to call this method, what's the benefit? Why don't I just write my own function to do all the sorting I need to do? Well, here's the deal. You do not need to write a sorting algorithm here. The Swift array already knows how to sort and rearrange hundreds or thousands of elements and do it very efficiently. All this closure needs to do here is take two elements, for us, two Book instances, and say are these two books in the right order or not? If they're okay in the order they're in, return true, if not, return false, because that question is the only thing it can answer for us. So if I had an array of 5, 000 or 10, 000 books and I wanted to sort them all by their readingAge property, the closure code just needs to ask one simple question. Given any two books, I'll call them firstBook and secondBook, we look at the readingAge property, and if the firstBook.readingAge is less than or equal to secondBook.readingAge, then they're okay as they are, return true; otherwise, return false. That's it. We don't need to actually rearrange anything ourselves. The array will take care of it because if we tell the array how to compare two of our items, whatever they are, it knows how to take care of sorting 10, 000 of them. Now your next question might be okay, but how would I know that? How would I know that's what the closure needs to do just from reading this function type? But when you have a method that accepts a closure and you've never used that method before, you should click through to read what that closure is supposed to do. Now, sometimes the wording can be a little convoluted, but it will tell you in the definition in the description. So finally, let's go ahead and do this.

Using Closure Syntax: How to Write (and Read) Them
So let's step through the syntax, and as I said in the initial clip, the first couple of steps here won't be that useful by themselves, but they will allow us to climb up that learning curve. To review, I have some code that creates an array of books, and I want to sort those books using the sorted by method of the array. That method expects a closure, which takes two Element parameters. For us, Element is Book, so we need a block of code that takes two Book parameters and returns a Bool. Now as a new Swift programmer, the first couple of times you work through closure syntax, here's an approach that can help. That instead of thinking about closures, I start by just making a function that does this, a normal Swift function that takes two Book parameters and returns a Bool. I'll call this function compareTwoBooks, and inside it have the code that I mentioned a moment ago. All I'm trying to do is take these two parameters and figure out if they are already in the order that I want them in. If firstBook.readingAge is less than or equal to secondBook.readingAge, it's fine. We return true. Otherwise, return false. Now, here's the thing. I am doing this, making this function as a stepping stone, but I could use this function to call the sorted by method of the array. Again, a function is a closure. It's a closure that's been given a name, but still it is a closure that takes two Book parameters and returns a Bool. So I'll do that. Now, sorted by returns a new array, a sorted version of the original, so I'll accept this into a new constant called ageSortedBooks and call allBooks.sorted. I can see that the sorted by function is expecting Book, Book that returns a Bool. And I will pass in my new function that I created a moment ago just using the name of it. And functions are considered first-class types in Swift. So the language is just as happy with you passing a function as an argument as it is with you passing a string or a Bool or an array. Okay, we don't do it as often, but you can. Though a quick sidebar moment. If I ever need to pass a function as an argument like I'm doing here, I don't use parentheses. This sometimes catches people out because they're so used to always having the parentheses after a function name. It is a small but important distinction. Think about this way. The parentheses are what we use to call a function, but I'm not trying to call this function here, get a result back from calling it, and then pass the result over into this sorted by method. I just want to pass the function itself and all of the code it contains, so I just use the name of it. End sidebar. Now I'm in a playground, so if I just write the name of the new sorted array on the line below, I can then use the show result button to make sure that all the results are being shown here in line. And we now have a new array sorted by the readingAge property. So using this function does work. But if you showed this code to a room full of Swift programmers, they would consider it incredibly verbose. But if I wasn't planning on using this function elsewhere, there's no reason to create it and name it in one place and then refer back to it somewhere else. So I can start to reduce this code, converting this function into a closure expression in three small steps. Now I'll just comment out the code below while I'm doing this. Step one, get rid of the func keyword and the function name because we don't need a name. But now this doesn't make sense to Swift. We do have curly braces for our block of code, but some of our code is inside the curly braces, and some is outside. So, step two, take the parameters and return type and put them inside the curly braces. So that's one step forward. Everything is now inside this block of code, but now we have lost the boundary, the division between the parameters and return type and the rest of the code, the actual code we want to run. So that leads us to step three, that in a closure we use the word in to separate the function type from the rest of the code that we actually want to execute. This is now a valid closure expression. It's a closure that takes two Book parameters and returns a Bool. However, I'm still getting a warning here because Swift is looking at this and saying, well, okay, but written like this, it isn't doing anything. This would be like writing an integer literal right in the middle of your code. The point of writing a closure is you want to pass it. So I'll take this entire closure from opening brace to closing brace, cut it, and then down here where I was passing the name of the function, I just paste this in here, and we paste the entire closure. This closure is now the argument into the sorted by method, and it's this that is the classic use. We're writing closure expressions in line, directly in the call that we're making. And just to check this, I uncomment the line pointing to the array, and we can see that it's doing exactly the same thing. It's sorting by readingAge. We're now using a closure expression. But I will admit this is still a little bit clunky looking, and that room full of imaginary Swift programmers would look at this code and still say way too verbose, way too much code going on here. So we can shorten this, and we can shorten this a lot. And when we start to shorten closure syntax, things will get very concise very quickly. First, I have the function type written here inside the closure expression, that this closure takes two Book parameters and returns a Bool. But I am now writing this closure directly inside this method call to sorted. It's in a place where the only thing allowed here is a closure that takes two Book parameters and returns a Bool. So this is now redundant. It's basically like type inference. Just like when something can only be a string, you don't need to say :string. When a closure is written in a context where it must have certain parameters and return types, so I can just delete those, and I also don't need the in keyword. But this leads to the next problem because I just removed the line of code where I provided these two names, firstBook and secondBook, for my two book parameters. So next, when the closure you're writing has parameters, and to be clear, I don't have a choice about this here, if I want to call the sorted by function, this closure will be given two parameters, and what Swift's going to do is generate implicit automatic names for those parameters with a dollar sign and a number starting at 0. So I can just replace the name that I was using for my first parameter with $0 and the name I was using for the second parameter with $1. If the closure had more parameters, it would be $2, $3, and so on. And notice I am still getting type inference. It knows that $0 represents a Book struct, so I have all the properties of that. So we're getting more concise, but we're not done yet. You see, nobody likes this, writing the curly braces inside the parentheses. So when a closure is the final or the only argument to a method call, and this closure is the only argument here, you can take the closure expression from the opening brace to the closing brace and put it outside following the closing parentheses of that method call. This is called a trailing closure. It is technically still part of the method call, but we can write it outside of it for readability to easily see the block of code. And here's the thing. If this closure is the only argument to this method call, and it is, and we've already put it outside the parentheses as a trailing closure, then these parentheses are kind of redundant as well, so we can pull them. But we're still not done because I make this code simpler. And this is very often true with closures used for sorting and filtering because they're often just simple comparisons or equality checks with true or false results. And this expression here where I ask if the readingAge of the firstBook is less than or equal to the readingAge of the secondBook, this by itself is either true or false. So instead of having a whole if/else block, I can just return the result of asking that question, of using that expression. And now we're down to a trailing closure containing a single statement returning the result of an expression. Let's just write this all on a single line. There's yet one more thing, because if a closure is down to a single line that just returns a value, returns some expression, and just to let you know that is not unusual, then this return keyword is considered redundant too, and I can delete that. And this is the kind of thing you'll see with closures. As I said, we get very concise very, very quickly. And that means I could write another line very similar to this to create another sorted array, but this time just using the syntax to sort by page count and view its contents. And another one, sorting everything by last name ascending. Though there's a small problem here as I'm viewing what's in this nameSorted entry. Most of them seem okay, but I've got this name de Saint-Exupery at the end because I'm comparing strings here. All lowercase letters, like the lowercase d, come after all uppercase letters. If I didn't want this, I could change this closure to call the uppercased method of this string and make sure that I was only doing the comparisons on uppercased versions of these entries. It won't change the actual results in the array, but it does affect the comparison the way that I want it to do, and now they're in alphabetical order. But sorted isn't the only one. There are other methods on the array, like map or filter, that work with closures. So filter allows you to create a filtered version, a smaller version, of the array. So if I wanted a version of the array containing only the books with a reading age less than 10, I can write that closure. It takes one parameter representing an element in the array, and that'll be represented with $0, and just returns a Bool where I can say do I want this particular item or not? So I could have written that as a full if/else statement, so if.readingAge less than 10, return true, else return false, or as with the earlier example, just whittle it down to this very concise syntax, a new filtered array of only those books where readingAge less than 10. So as you're probably starting to see, when you get comfortable with closures, you can do things here in one line of code that would take loops and conditions in other languages. And that's a great thing, but the syntax can be so concise it can baffle people new to the Swift language. They look at some closure syntax and think hang on, what? What does this do? What are the dollar signs? Why doesn't that look like a normal function call? Where have the parentheses gone? And that's why I spent the time here. And I hope you found it useful to do it this way, to see how we could take a function and turn it into a closure and then start to pull even more away from it, that we can remove parameters and return types if they can be inferred. We can then use numbers instead of having to name every parameter. And if the closure is the last or the only argument to a method call, we can write it after the parentheses as a trailing closure. And if we can get our closure down to a single statement, a single return, we don't even need the return keyword. Okay, there are a couple more advanced features of closure, but I'm not going to cover them in this course. We have done enough, and you'll be able to do a great deal with closures using what we've covered here. And if this was totally new to you, congratulations. That was a lot to go through. Let's move on.

Using Classes and Objects in Swift
Defining Classes
Swift is an object-oriented language, and with many of the things we'll want to do with Swift, like iOS and macOS development, we will be using existing object-oriented frameworks. We will need to instantiate objects from classes that have already been written, many of them written by the folks at Apple. And we'll also want to define our own classes and make instances of those. Just to be clear, this is not a module about object-oriented programming. I am making the assumption you're comfortable with at least the core concepts here, terms like class, object, instance, and inheritance, that they're familiar to you. As always, I'm going to focus here on how Swift does all this. So, as with functions, as with optionals, as with structs and enums, there are, of course, two different parts to the syntax that we'll need here. There's a syntax for defining our own classes and the syntax to instantiate objects from them and use those objects. So first, let's define one. It's simply the keyword class, then the name of the class you want to make. As with structs and enums, we are defining a new type here. We'll be making instances of type Appliance, so it's an uppercase first letter. And then inside a set of curly braces, to add properties to a class, just add variables and constants. That's it. There's no special keywords needed. A variable or constant defined inside a class becomes an instance-level property of that class. If I was to use let to create an instance-level constant property, it follows the same rules in that it could only be given a value once for each instance of that class. And we also have the same rules with the data type of each property. If you provide an initial value, Swift will infer the type. If you don't, you provide a type annotation. But Swift is complaining up here that we are not providing initial values for this variable, and Class 'Appliance' has no initializers. And that's because when we make an instance of this class, it's going to immediately create all these variables, so they always need to exist in a valid state. So I can either provide an initializer for this class to make sure they're set, and we'll do that in a moment, or I can provide explicit initial default values. And right now, I'll just do that using the Xcode fix it to set basic values of empty string and 0. Now I don't need to provide a value for the last one as it's defined as an optional integer. Next, to add a method to a class, we just add a function. Again, that's it. No special keywords needed. A function written inside a class becomes an instance-level method of that class. Inside this method, I'm using the word self to refer to the current instance. You might be used to the keyword me or the keyword this for the same idea. Now technically I don't need to write self here. Swift would assume I was referring to the properties of the current instance, but the keyword is useful if there's any potential for conflicting names. So we now have a defined class with both data and behavior. In a typical project, we would write each class in its own file. I'm just using a single playground to keep it simple. But of course, there's no point in defining a class if we don't actually use it, so now I want to create instances of this class, and this is how we do it. In Swift, we do not need a special keyword like new or alloc or init to create a new instance. Just using the name of the class followed by empty parentheses means create a new object of this class. I'm in a playground, so I can then write just the name of the new instance and click the show result button to see that it contains all those properties with the default initial values I've defined of empty string 0, and we have nil for the optional. Now this new instance is type inferred as an appliance, so if I hit the dot, I'm going to expect to get all the properties and all the methods of it. And I use dot syntax to either access or to change the properties of the instance or to call its methods. And this is the basics of classes, defining them, instantiating them, and using them. But there a few more things to cover, so next let's talk about initialization.

Adding Initializers
In the previous clip, I was using default values, the empty strings and 0s here for every property in this class, and that's because Swift won't let us create an instance of a class and only then provide values for everything in it. It must be created in an entirely valid state. Now another way to ensure this happens is rather than provide these explicit values, which you can't always do meaningfully, we can create an initializer method inside the class. In Swift, this just means a method called init. Now we don't need the func keyword before an init method. It's understood this is a special method, an initializer, and it's similar to constructor methods in other languages. An init method with empty parentheses will be automatically called when we create a new instance of this class using empty parentheses. Now right now this is giving me an error because this so-called initializer doesn't initialize anything. So inside the init, I will initialize all my properties. Again, if a property is defined as optional, like I have for the capacity property here, then that's allowed to remain uninitialized. So this default initializer takes no parameters. You can create additional initializer methods as long as they have different parameter signatures so you can tell them apart. Then when you create new instances, you'll get a choice of which initializer you want to use. And after that, use dot syntax as before. A class can also be given a deinitializer written with the word deinit. Now there can only be one deinitializer in a class, and it is a special one. Again, we don't need the func keyword. It is just deinit. And it has no parameters, and it returns no values. Now deinitializers are nowhere near as common as init methods. Most of the time you will not need one. But they can be used if an object needs to perform some explicit cleanup code, like releasing a file resource before it gets deleted and if there's no other way to make sure that's happened. But a quick sidebar moment. Swift uses something called ARC, or Automatic Reference Counting, that manages memory for our objects. ARC is not something we're going to dive into in this fundamentals course, but when we create instances of classes and they are allocated in memory, ARC is what keeps track of whether that instance is or is not still in use. And when it detects an instance is no longer used, for example, if it was created in a function call and now it's dropped out of scope, ARC is what handles deallocating and freeing up the memory for it. And it's in that process that Swift will call any deinit method if you have one. So even though you might write a deinit method, you never call it yourself. It is called automatically just before Swift deallocates the memory for that object. But there's one more thing about deinit. This is one of the few things that I've talked about in the last few minutes that can be written in a class, but it can't be written in a struct, and it's time to revisit the differences and the similarities between classes and structs in Swift.

Revisiting Classes and Structs
Earlier in the course, I said that structs and classes are very similar in capability. In some languages, like C, structs are often much simpler and much more restricted, used as a basic container for a few pieces of data. But in Swift, they are powerful. Structs can have methods, they can have properties, they can have initializers, but not deinitializers, and again, the data types we've been using, strings, integers, arrays, dictionaries, these are all written as structs in Swift, not classes. They are defined in a very similar way. In many cases, if I took a basic Swift class and changed the word class to the word struct, I would have no problems at all. Everything would continue working. They can be instantiated the same way, as I'm doing here. We don't need the word new or alloc or init. We just create a new instance using either the name of the struct or the name of the class and the parentheses that will call the right initializer of that struct or of that class. So if these are the similarities, we've got properties, we've got initializers, we've got methods, let's talk about the differences and begin with one difference with initializers. So I'll strip this back to a basic struct just with a couple properties. I haven't provided an initializer or any default values here. When I create a new instance of a struct, Swift with automatically generate a simple initializer method containing arguments for each property in the struct. This is called a memberwise initializer. If you don't want this, you can write your own init method in the struct, but if you are using a struct as a basic data structure, this is a great timesaver. However, if I change the word struct to the word class, I'm going to lose this generated memberwise initializer, so I'll either have to provide my own init method or make sure that every property that I've written here does have a default value. So I'll change this back for now. Now difference number two is that if you define a class, it can take part in inheritance and inherit the data and behavior of another class. Structs cannot do that. But we're going to talk about inheritance in the next clip. But perhaps the most important difference is this, that structs are value types and classes are reference types. When you create an instance of a struct, whether you've defined it yourself or you're using an int or a string or an array or one of the built-in structs, and then you either use that to assign to some other variable or constant or to pass it into a function, the value of it is always copied; it is duplicated. But when you create an instance of a class, it is a reference type. And when you pass it to a function or assign it to another variable or constant, it is not copied. A reference to the original reference is used, and any change to it can affect the original object. In some languages, you have to think about this difference a lot. You don't have to worry about it as much in Swift because of things like function parameters always being constant by default. But let me quickly demo this anyway. In a new storyboard, I will create a string variable and give it a value. String is a struct here. It is a value type. And if I then assign it to a second variable, I am copying the original value. I'm making a duplicate of the string contents. If I then change that second string using += here to concatenate, I am changing the copy of that original value. So if I print out both secondString and firstString, they're different. String are value type in Swift, as are ints and Bools and doubles and arrays and dictionaries. So let me go ahead to reference types. I'll just comment this code out. In Xcode, you can select a block of text and hit Command+forward slash to add the two forward slashes at the start of the line. You can hit Command+forward slash again to toggle that on and off. Okay, now a very simple class, and I do need to define a class here because there's nothing in the Swift language itself I can use to demo this. So I'll define a class called Message with a single string variable property called internalText and give that a value. I'll now make an instance of this class. It is a reference type. And if I then assign that to a new variable, to a second variable, it is not a copy. Unlike the string example, we don't now have two separate instances. Both of these variables are referring to the same object. So if I then use the variable called secondMessage and change it's internalText property, I am changing the only instance of this that exists. And okay, this is a quick and dirty example, but it does prove the point. But as a final touch, if I take this class here and change the keyword class to struct, we will immediately see the difference. Where we had the two print statements that were printing out the same string, they will now print different strings. Because with a struct, we are making a copy of it when we assign it, so we'll have two instances independent of each other. Now if I change this back to a class, we're now back to a single instance. And because when you're working with classes we can end up with multiple references to the same object like we have here, if you need to check whether different variables or constants are actually referring to the same thing, you can use the === sign. This is called the identity operator, and it only works with classes or objects of classes because it's specifically for us to ask if these two different names that I have are actually pointing to the exact same instance, are they identical rather than equal? Before I finish, a quick sidebar here. I'd like you to consider whether I could use the word let to have defined firstMessage and/or secondMessage as constants here rather than variables, bearing in mind I am going to try and change the internal text property of them. Now if you're thinking, well, it probably can't be a constant because if we then want to reach in and change it, but in fact, I could use let to define this as a constant, one or the other or both of them. What this says is that this firstMessage is itself constant. I initialize it once by creating a new instance of the Message class. Now what I can't do here is change that firstMessage constant to point to a different instance of Message. I'll get an error for this. But because the string inside it, this internalText, is defined as a var, I can still reach into the object, and the object is staying constant, and change the property inside it, which is variable. And so long as I don't want to reuse these names firstMessage and secondMessage to point to totally different objects, then I can and should define them as a constant. However, this is true if it's a class. It is not true if it's a struct. If you have a struct created with let, then it's a constant, and everything inside it is constant. Now let me finish this clip with a small comment about terminology. That in Swift, because structs and classes are so similar, you tend to hear the word instance used a lot more than the word object, because we can use instance to refer to either instances of structs or instances of classes.

Implementing Inheritance and Overriding Methods
When I define a new class in Swift, I can inherit the functionality of another class by following the name of my new class with a colon and then the name of that existing class. So this colon that we've been using in a lot of our variables and our constants still represents a type of relationship. New class Toaster is a type of Appliance. A terminology moment. Some languages describe inheritance with phrases like parent class and child class or base class and derived class. In Swift, we say superclass and subclass. We inherit here from Appliance. It is the superclass in this relationship. Our new class is Toaster. It is the subclass here. Also worth mentioning, in a few languages, any new class you create automatically inherits from a default universal base class. That is not true in Swift. If you don't see the colon, as with our Appliance class, it's not inheriting anything. Now this new Toaster class will get all the properties and methods from the superclass, so without adding anything else to this, I could just go ahead and create a new instance of Toaster and get to its properties and call its methods, all of them defined in the superclass Appliance. But the whole point of inheriting is that I want to change or add on to existing behavior, so I can go ahead and add an extra method in the new class, method called toast. This will now be available on instances of Toaster, but it won't be available on instances of Appliance. And we can also go ahead and add new properties to this class. However, we're going to immediately run into an issue because we're creating a new instance, and we're implicitly using the inherited init method that's defined in the superclass that initializes the make and model properties. So when I add this new piece of data, this new property, the inherited initializer isn't good enough anymore. Now there are a couple of options. I could provide a default value for this new property, and that would at least allow us to create it, but the other way would be to add my own initializer inside this new class. But because we're in an inheritance relationship, if I just add an init method here, we're going to get another error because I'm already inheriting the init of the superclass, so there's a potential for misunderstanding. And Xcode with suggest a fix it here to add the override keyword, and we must do this if what we want to do is replace any inherited behavior with our own version of it, and the compiler will prompt us to add that override if you forget. So now inside this override init, I will add a line to give my additional property a value of 2. Now there's a convenient feature here, and because these two classes are so simple with only a single init method each, that when I make this new instance of Toaster, Swift will first now call its init method to initialize this new property, and then it will automatically reach up and use the init method in the superclass to initialize those two properties as well. And that's because when we override initializers as opposed to overriding other methods, we're usually just wanting to add on to any existing initialization behavior rather than completely replacing it and having to rewrite it. However, if I did want to make the call explicit, to call from the subclass, Toaster, into the superclass, Appliance, I can use the keyword super. I can get access to the things defined in that Appliance class, which is the make and the model property, the printDetails method, and the init method. So I can call super.init. Now the flipside of this is if I want to prevent a method that's in the superclass from being overridden in a subclass, I can add the keyword, final in front of it. Now we would not be allowed to override the printDetails method. And if I wanted to go one step further and prevent the entire class from being inherited, I can put the keyword final before the class. This would now stop me from inheriting it at all, so this immediately throws an error on line 15. Now this is the basics of inheritance in Swift. Now there might be some folks expecting me to go a lot deeper into it, but I'm not going to, not in this course. And if you're coming from a language where inheritance is really common, like Java or C# environment, understand we just don't use it as much in the Apple developer world. Even before Swift, with Objective-C, we didn't. Now it is used. It's just not this constant presence. Now with some technologies, inheritance is a constant part of the landscape. You're always inheriting from something. Even when you make an app, you always inherit from an application class. We don't do that here. We get similar results, but with different techniques, like protocols and delegation, and what we're going to see next, extensions.

Adding Functionality with Extensions
Extensions allow us to add new methods and new properties to an existing type without using inheritance and having the issues that come with subclassing and overriding. And extensions don't just work with classes, but also with structs and even with enums, which is good because we can't use inheritance with those anyway. And we can use these extensions to add extra behavior, not just to our own types, but to anything. Here's an example. We're using Swift strings all the time. They are great, and they do have some useful functionality. For example, they contain methods to create uppercase or lowercase versions. But let's say that I deal with a lot of strings, and I wish that every string had a built-in method to convert every piece of white space to underscores, or to remove profanity, or to capitalize them in some custom way, or just to delete all the spaces in a string. Now String doesn't have those methods, and we can't change the built-in Swift String type, and we can't subclass it because it's a struct, not a class, and it doesn't do inheritance, but what we can do is add an extension to it. An easy way to add our own methods to the String type, and then in our code every single string instance will have these new methods. And the syntax is the keyword extension and then the name of the type you want to extend. For us, it's String. And you can extend a class, you can extend a struct, or even an enum. Then it's a code block to contain any new methods or properties that we want. I'm going to add a method called removeSpaces. Looks like a normal standard method here. Doesn't take any parameters, and I want this to return a new String. Now this method is called on any instance of String, so I can use the word self to refer to the current instance, whatever the current string is, and then I want to remove all the spaces inside. Now there's a few ways to manipulate strings, including regular expressions, but here's how I'll do it. In Swift 4, we can treat a string as if it's a collection, as if it's an array of all the individual characters inside it. So I could use something like a for in loop to iterate over every character, but I can also directly use the string as if it's a collection. So I'm using the word self, which represents a string, and in the closures module I briefly showed the filter method, which is designed to iterate over a collection one element at a time and create a smaller filtered version of that collection. And the filter method takes a closure that will be automatically called for each item, so where each character will be represented by $0. So this is the very concise closure syntax that will let me say make a new collection of characters by using every character that is not equal to a space. Then I'll take the new array I just created and make a string out of it and return that. That's it. This new method is now available on every single string in our program. And that's extensions. You can add methods, you can also add properties, you can add initializers, whatever you want to add on to an existing type. Now to be clear, with extensions, we are always adding something. It's not inheritance. We're not merging anything. We're not thinking about overriding or the superclass-subclass relationship. It is simpler than that, and it's easier than that.

Using Computed Properties
We've seen that properties can be added by just writing variables or constants and putting them inside a class, or inside a struct, or even inside an enum. Now these kinds of properties do have a more specific name. They are called stored properties, which means they store their own individual values for each instance. Now this is normal. When we talk about properties, we usually mean stored properties, but there are other options. We can also define a computed property, one that calculates a value every time we ask for it rather than internally storing one. Here I have a simple class, although what I'm about to show works exactly the same way with structs too. This is called Player. It contains a few of these typical stored properties. Our player has a name, and then Ints for livesRemaining, enemiesDestroyed, penalty, and bonus. But what this Player class doesn't have right now is a property to keep score. Because let's say that in our game a player's ongoing score is a calculation of the enemies destroyed, plus any bonus, minus any penalty, with extra for lives remaining. Now we could write a function to calculate the score, but really score doesn't feel like a function. Score feels like a piece of data that belongs to this player. It's just a piece of data that's based on other pieces of data. So, to make a computed property, it begins by looking like a normal property, a normal variable, var score: Int. But we're not quite finished. Now, instead of providing a value or setting it directly, we add a code block after the type, and inside that we add another code block with the word get before it. And you can also add another code block to set the value. Now with computed properties, it is very common to only have a get block. This makes it a read-only computed property. And that's actually what I want here because I don't want any other code trying to change the score. It's always going to be based on the other values stored in this player. So I'll just delete the set block for now. Now I can add a return statement with a calculation. After creating the instance of Player, I can just ask for that calculated property. So I can write code that behaves as if score is a piece of data that belongs to the player. It's really a function, but this is a preferable way to get to it. If I try to set it, I would get an error telling me score is a get-only property. If I do want my computed property to be setable, I'll add the set block back in. What happens is when someone tries to assign a new value to this property, this block will be called, and it will automatically have a new value passed in, and it's implicitly called, appropriately enough, newValue. Now by the fact that I provided a set block, this attempt to set score will work. It passes in 125, 000. I can see that that new value has been passed in. Even though I'm not going to try and pull it apart and actually change any of the internal stored properties of this, I can at least show that it is working. But for this example, it does make sense for this to be a read-only or get-only property just having this get block. So I'll remove the set block and the attempt to assign a new value. Because we often do have computed properties that only have a get block, when that is the case, you can even omit that block too. You can make this computed property more concise just with one code block inside to return a value, and Swift will look at this as a read-only computed property. But a sidebar to finish. There is a common misconception with a read-only computed property like this that it's read-only. So if we can't change it, that's like a constant, so we should probably define it with let. But no. Let is not allowed with computed properties, even read-only ones. It has to be var, and the reason is that even if you don't allow a computed property to have a set block, that's not the same thing as a constant. So I've got this property, score. It is a calculated property. It's created from the other variables. And while it is read-only, this is not a constant. Because if I asked for the score a hundred different times through the life of the program, it could be different every single time, and that's not the way a constant behaves. So calculated properties are always defined as a variable, even if they're read only.

Introducing Protocols
Introducing Protocols
In the last module, I said inheritance is not as common in Swift as it is in other languages. We can do it here, we just don't do it as much. And if you've used inheritance in several projects, you know there are different reasons for it. Sometimes it's because a programmer just wanted to take an existing type and add on some additional behavior. Well, in Swift we don't need to inherit to do that, we just write an extension, but sometimes inheritance is used because there's a desire to standardize some behavior. There are multiple types that are the same kind of thing, or should have similar behavior, have the same set of methods or the same properties, and in Swift, a protocol is a way we can formalize some rules about what a class, or a struct, or an enum, should do. And, again, without worrying about inheritance or whether we truly have an is-a relationship, and these are not esoteric or infrequent techniques. Protocols are a common, everyday task in Swift programming. And although the syntax is simple, and it really is, the idea runs deep. The engineers at Apple call Swift a protocol-oriented programming language. And they're not trying to suggest it's not object-oriented, sure it is, but this about priority, that in Swift it is more useful to think about protocols than to think about objects and class inheritance. But if this isn't a word you're used to in programming, that's okay, you can begin by thinking of the word protocol and how it's used in diplomacy, or medicine, or even etiquette. It's a set of rules, a code of behavior. What are the things you have to do, and in what order? What is the protocol for treating malaria, what's the protocol for meeting an ambassador, what's the protocol for attending the Vienna Opera Ball? It's when there are certain things expected of you to be part of some event or some procedure. And it's not arbitrary, there is an actual list of rules. Maybe just a few, maybe only one, but anyone who can follow the protocol can do that thing. But how does that apply to programming? Well, it's the same, because the important idea is that something is already going on, and if you can follow the protocol, you can take part in it. In Swift, a protocol is a simple list, often an extremely simple list of some methods and properties that a class or struct or an enum is supposed to have. And they aren't just used in one kind of situation. Protocols can help with general purpose tasks, they can also help when building iOS apps or MacOS apps. They're used with everything from loading and saving data to very specific things like spellchecking text fields or making dynamic and resizable user interfaces. But, when it comes to code, this is a subject that's almost always taught the wrong way around. Everybody begins by saying, look, here's the syntax to write a protocol, and true, the syntax is simple, but it gives the wrong idea, because you don't begin by writing protocols, you begin by using ones that already exist, that were already written. Many of them are part of the language, or part of the frameworks for developing applications. So here's one example. I'm now in the Xcode documentation view. I'm looking at the information about a protocol called CustomStringConvertible. This is part of the Swift standard library, the core of the Swift language. in a second, I'll show you why we find it useful, but let me come down here to this section that says Protocol Requirements. And this says, if I want a class, or a struct, or an enum to support this protocol, and the term we'll use is to adopt this protocol, then we must have a property called description, which is type of String. And that's it, that is the only requirement here. A protocol itself has no implementation, it contains no behavior, no code. This doesn't say anything other than, you need a description property. But why? Okay, I'm going to use a class here, but in Swift we can also do this with structs and enums. I have a player class, and currently I can create a couple of instances, I can set their properties, but if I tell Swift to print these instances, and not print a property of them, but print the instance itself, what I'll get as output is something like this, an unhelpful message that basically says this is an object of type Player. Now could I write my own print player details method and call that? Sure, but a preferable way is to adopt the protocol I just showed, and I do this by, after the name of the class or the struct or the enum, I add a colon and the name of the protocol. This is the same syntax we saw with inheritance following the class name with a colon. And as a side note, if I had also wanted this class to inherit from a superclass, I would put the name of that superclass first after the colon, then a comma, followed by any protocols. And while you can only inherit from one superclass in Swift, you can adopt multiple protocols by separating them with commas. So I have now volunteered this class to adopt this protocol, but by writing this, Xcode is now complaining, because I have said my class adopts the protocol, but it doesn't actually follow through on that yet, and the compiler is checking to see if I have the methods and properties that were required by this protocol. And what's required is a property called description of type String. Because I've added the protocol name, if I type the first few letters of the property, des, I will get it here, and I can get auto-complete to fill it out, and I can, just for the moment, provide a literal value for this, and this looks like a completely normal, boring, variable property. You see, the protocol doesn't care if I have implemented description as a stored property, or a calculated property, or just a literal here, whether I've done anything meaningful or complicated, all it requires is that I provide a property called description of type String. But notice, in the output for the print statements, this is the value now being written out, just test. So let's make this property more meaningful. I'll change this to a calculated property using a single code block to build a more useful string representation of any Player object. And now we get that information that's unique to each instance. I'm now tapping deeper into the language, and Swift will automatically shift to my description property whenever I print an instance of this type. And this is the point, and this is the benefit of adopting a protocol, is that by doing it, you will be able to take part in something you weren't part of before. And there's nothing magical about just having a description property, I could have even had one already. But by also saying we adopt CustomStringConvertible, I am now able to tap deeper into the language. And notice, this description is now not just being used for that print statement, but it's also being used in the playground results. And I could adopt this protocol in all of my types, and I could provide custom string representations for everything. And when you adopt a protocol, it doesn't restrict you in any other way. I can still have anything else I want in this class, methods, properties, initializers. Now if I do decide that I want to write a protocol, it is just a list of necessary methods and properties, and the code looks like this. It's the word protocol, and then whatever we want to call it. For methods, it lists the names, the parameters, and the return types. So this would be how I would say anything that supports or adopts this protocol needs to provide a method called showMessage that takes no parameters and returns nothing. And, again, the protocol itself contains no implementation, no code, not even curly braces, they're not allowed. You can have methods, you can have properties, either or. For properties, the protocol doesn't say whether the property is a stored property or a computed property, it just says, the property needs to have this name and this type. But, a property does require a set of curly braces to come after it, not for behavior, but just to contain either the words get, for a read-only property, or get set to say this is a read/write property. And this is now a protocol that any class, or struct, or enum can volunteer to do. And for that class, or struct, or enum to conform to this protocol, it must provide actual implementation of these exact methods with these names, these parameters, these return types, and provide any properties with these names, with these types. Terminology side bar. There are two words you will hear when talking about protocols, adopt and conform, and they can seem almost interchangeable, oh, in this struct we adopt protocol x, oh in that struct we conform to protocol Y. The difference is about what part of the process you are focused on. So when you decide to use a protocol and you make a struct or a class or an enum and type colon protocol name, like I'm doing here, we are adopting that protocol. We're telling Swift, yes, I'm going to do this, great. But this protocol requires me to provide one method and one property, and if this is all I've done, I may have adopted the protocol, I haven't conformed to it yet, because I haven't done what the protocol asks. But once I write the code to provide everything that protocol requires, now I would be conforming to the protocol. That's the difference. End sidebar. If you were coming from a Java background, you may be thinking, well these are kind of like interfaces in Java, and yes, there are a few differences in implementation, but there's a lot of conceptual similarity, and Java interfaces were originally inspired by protocols from Objective-C, which is a huge part of Swift's ancestry. Okay, there are some advanced features or protocols, but this is enough to meaningfully use most of the protocols you'll encounter when programming in Swift. I won't pretend that they'll all be as simple as CustomStringConvertible with its single description property. With many protocols, you'll need to provide two or three or four methods, sometimes more, but there is one very common protocol we're about to see that's even easier than CustomStringConvertible, because to conform to it you don't have to do anything.

Defining and Handling Errors in Swift
We're now going to go over errors and error handling. And, okay, the word error does have a few different meanings, so to be clear, I'm not talking now about catastrophic runtime errors or logic errors that'll crash our program, because we hope to find those during development and make sure they never happen again. This is now about recoverable errors, the undesirable, but semi-predictable situations in our code, the things we will try, we want them to succeed, but we also know they might fail, and we must handle any failure well. Your app is trying to save a file to the cloud, but the user just turned on airplane mode, or the Wi-Fi just disconnected, or we moved out of cell tower range, or the server just disappeared, or we got an authentication error, or we're trying to write an app that'll record audio files, but the user might run out of space, or they might not allow us to access the microphone, or there's no audio input device selected. We hope these things don't happen, but we know that they might. Now with some errors we'll be able to handle things behind the scenes, and try something else in the background. With other errors, we might pop up a message saying, hey, we saved this locally, and we'll attempt to upload next time you're connected to Wi-Fi, but with others we might just have to say transaction failed, please try later. Now when it comes to the code, there are three parts to any error handling scenario. Part one is we define an error, we think about what a potential error could be in some part of our application. We might have an error connecting to a server, or an error in saving a file, or an error in some complex calculation, we define it, we give it a name and any information we need. But, just as there is no point in defining a class or a struct or an enum if you're not going to use them, there's no point in defining an error unless some other part of your program will use it, and contain logic to say, hey, we got one, this error just happened. So that's part two. Some other part of your code can decide the error has happened, and will throw the error, and that's the term we use, we will throw it. But likewise, there is no point in throwing an error, and announcing that one just happened, if there isn't another part of the code that can handle it and deal with it. So that's our three parts, define it, throw it, and handle it. Now when defining an error, for many programming languages there is standard error type, perhaps an error class you instantiate and then provide with properties. Now sometimes this is way more complicated than you need, sometimes it's not complicated enough. So Swift does not provide a built-in error class or an error struct. Here, an error is whatever you need it to be. It can be as simple or as complex you want. If your errors need huge amounts of additional information attached, you could do that, you could build out a very complicated struct. If your errors just need to say error 1 or error 2, you could do that as well. So you define your own error types, and you can define multiple error types in your app. They don't have to inherit from any specific class, they don't have to provide any particular properties or methods, you can define them as a struct, or a class, or an enum. And an enum can be a very useful way to define errors. So let's say there's a point in my program I know I'm going to reach out to a remote server and check its status, but I realize that request might occasionally fail, and it might fail for a few different reasons. So an enum is useful, because I could define something called, say, ServerError, and then within it I could make the distinction between a server error that's no connection, or server is not found, or there an authentication problem. There could be other reasons, but that will do for now. And these choices, these names are completely up to me. There's nothing here that Swift enforces. Right now this is just a normal typical Swift enumeration, you just define your own. But, so that we can also tap into the Swift error handling mechanism, which we'll see in a moment, I'm going to add one thing. After the name of the enumeration I add a colon, and then Error. And Error is a built-in protocol in Swift. But the error protocol is an unusual one, because when you adopt this one, you don't have to provide any methods or any properties. I don't have to add anything at all to this enum. You see, the reason that we do this is just as a way to mark this enumeration. We're telling Swift, hey, this new type I made, ServerError, I'm just letting you know, I'm going to use this as an error, this is something I intend to throw. But as always, the point of adopting a protocol is you can then do something that you couldn't do before, and that is the error handling part of it. So now I have this marked as an error, I'll be able to use the keyword throw to throw it, and then handle it. So let's go ahead and do this. I'm just going to paste something in here. Now the code here is a little bit contrived, but it's going to be easy to explain it this way. So I've got a function called checkStatus. It takes a serverNumber integer and returns a String. And inside there's a switch statement that's just going to print out some messages. Now currently I may have some print statements saying that I have no connection or authentication failed, but however I do this, the function will always return that Success message. So I'm going to change this to make everything except case 3 throw this new error. And the very first thing that I need to do is if a function might throw an error, we must add the word throws to the function definition, right after the closing parentheses for any parameters, and before any return arrow if you're returning anything, and then now inside my switch statement add a throw statement for the error enumerations. Anytime we hit a throw, that's going to mean an immediate return out of this function. So if an error is thrown, we will not reach this final line, we won't return a value, and this is all I need for part 2, the part of my code that can throw an error. Part 3 is that if a function might throw an error I need to show that I am aware of that when I call that function, and that's why we're getting this issue now on the calling line. Calling checkStatus is no longer a normal call, I can't guarantee this is going to work, so I have to call it differently, and let's go through a few options for doing that.

Dealing with Errors with Do-Catch and Try Statements
There are several different ways we can call a function when that function has been defined to throw an error. And one way is to wrap it in a docatch statement, and you'll find an auto-complete helper for that if you start typing. At the minimum, this is a do block followed by a catch block. Inside the do block, we will also need the try keyword to try to do something that might throw an error. If it does throw an error, we catch it in the catch block. I'll take the code I was using and put it inside that do block. Notice that I'm adding the keyword try here to the actual thing that might fail, which is the call to checkStatus. I'm not just typing try before the line. Now I'm going to start simple here. I'm just having a generic catch block. This will catch all errors in the same way. So if I call this passing in the number 1, I'll get the noConnection error, calling passing the number 2, I'll get the authenticationRefused, number 3, I will get the Success message. Now what's happening is whenever an error is thrown, it's being passed into this generic catch block, and it's being passed in with an automatic name of error, with a lowercase e, so that I could then print it out. However, I can also write multiple catch blocks. If what I want to do is have different catch behavior for more specific errors. So here I'll have a specific catch block if there's a noConnection error, another specific one if there's an authenticationRefused error. Now unlike a switch statement, the compiler will not force me to be completely exhaustive and create catch blocks for every specific enum, but it is good practice to leave this generic catch block at the end. So this is error handling using a docatch statement, and the do part is what's including the keyword try. But this is not the only way. You see, when calling a function or method that might return a value, but might throw an error, one possibility is you just may not care that much about the error, and you can think about the result almost as if it's an optional. So in this code I've revised a little bit of what I've done to define result as an optional string. And then I have that do catch statement where I try and get a value for that optional, and if not, I'm just going to make sure it's set to nil. So here I just may not care why an error occurred, I'm just trying to get a value. If I can get one, great, if not, just move on. So I'm behaving as if the checkStatus function I'm calling was defined to return an optional. If it works I'll get a string out of it, if it doesn't I'll get nil back. I'm just going to ignore the details of any errors. Now if that is what I want, there is a way to make this more concise rather than using a do catch statement. I can use try question mark. This will turn the result of any try into an optional. So if what we're trying to do works, we'll get a value, great. If it doesn't work and throws an error, we'll get a nil result. And because this does return an optional, I could use this format in an if let statement. So if the call to checkStatus works, we'll have a value, and we can use it. If not, we just move on. And moving on ourselves, there are two final keywords I want to cover in this course. They're often used with error handling, but they're not restricted to it, the Swift keywords, guard and defer.

Using Guard and Defer
The two final Swift keywords we're going to cover in this course are guard and defer. These count as control flow statements, like if-else or while, but they have their own special intended usage. So first up, guard. This statement is closest in spirit to an if-else statement, and you always see it together with the keyword else. Now you can get the same result from a guard statement by writing an if-else statement, but guard has a very specific scenario it is intended for, and it leads to simpler more readable code in that scenario. An example. Assume that we have a function defined with several optional parameters. That when this is called, what's passed in may or may not be nil. Now we would like to have values, but sometimes we have to deal with errors, and we have other issues where we can't guarantee it. So when this function runs, the first thing we have to do is check all these parameters that did I actually get a value for trackName, and for artist, and for duration. I might start writing long if-else statements to check for all the things I hope are not true. That if trackName is equal to nil or artist is equal to nil, or duration is equal to nil, I'm going to print out a message, and I'm going to either throw an error or just immediately return. And then in the else block I can start dealing with what I hope is actually true, that I have these values I can start forcibly unwrapping the optionals every single time I want to use them. So this is one way I could approach it, but it is kind of clunky. Another option would be to use the if let syntax to do optional binding. If the first parameter has a value, we'll check the second. If the second parameter has a value, we'll check the third. Okay, we don't technically have to do all this nesting anymore, but you will occasionally see this, and you'll see it referred to as the pyramid of doom, multiple if let statements, one nested inside each other However, if all we're trying to do is use optional binding to check and unwrap multiple values, we can just have multiple let statements separated by commas surrounding one if block. And now we'll only drop into the body of this if all of these have values. However, I would still need an else block here to make sure that we can return out of this function if we didn't get values. So this is also kind of clunky. So we're going to use a guard statement. Guard allows us to focus on what we hope is true, and if it's not true, exit very quickly. Here's the syntax, the keyword guard, and then a condition that you need to be true. Then an else keyword and a code block that says if that isn't true, what are we going to do. Now a guard will check a Boolean condition, just like an if or a while statement, it must evaluate to true or false, and the condition is something we need to be true here, that a value is in a certain range or one variable is greater than another variable, or quite often that you need some optional to actually have a value. Next you must follow the condition with the keyword else and a code block, and that's the only code block you have with a guard. So unlike an if statement, which may or may not have an else, a guard must have an else, and that's all it has. And it's only if this condition is false where we drop into the else block and run whatever code is inside it. So the question may arise, what does the guard statement do if the condition is true? Nothing, we just move on onto whatever comes next. But here's the biggest difference between this and an if else. When you have a guard, you must have a hard exit in the else block, usually either a return statement or a throw statement, you can also have a break or a continue, because the entire point of guard is that you're describing what you need to be true, and you get the opportunity to have a very quick exit or an early return if it isn't true. And the else block in a guard is very often just that, that early exit. It's not unusual to see a line like this right at the top of a Swift function. It's a simple guard statement to say, this is a thing I need to be true, in this case the isActive property of searchController. If this is true, great, we'll move on; if it's not true, return immediately. But there's one other feature of guard very much worth mentioning. See, we've seen how to use the if let optional binding syntax, that if there's a value in this optional called optionalName, we're going to unwrap it, put it in unwrappedName, and that will count as true. But even if there was a value, it will no longer exist as soon as we're done with the if let statement. Well, we can also use guard let, similar to using an if let, but unlike using if let, now, if there is a value in the optional, the name that we're going to use for it, the unwrapped version, that will be available once the guard statement is over. It has to be, because I'm only going to get to this line if the guard condition is true. If I saw code like this with several guard lets one after the other, that's each testing to see if there's a value in an optional, and if any of them are nil we will have an early return right out of this function. But if I get to the line after them, I know that I'll have three unwrapped values that I can use. But one final thing, if I did see just a few simple guard statements like this, just testing for optional values, and where they all need the same basic return statement for an early exit, they can even be combined onto a single statement separated by commas. As I said right at the start, guard doesn't give you anything that you couldn't get another way, typically with an if else statement, but you do get a very concise syntax to describe what you need to be true, and to exit immediately if that's not true. And finally, the defer keyword, a simple one and a useful one. You see, it's not unusual to have a method that needs to open some resource, a file resource, a network resource, even a complex object. But in that function, it's also not unusual to find ourselves needing to write multiple places to make sure that however we end up exiting this function, we're always going to be able to close that resource or there's going to be problems. Defer takes care of that, and it is a simple syntax, the word defer, and a code block, nothing else. And whatever you put in this block will be called just before the block that you're in, most usually a function will drop out of scope. So here I could create a defer block right beside where I open the resource. This code won't be run immediately, but then I could remove it from all the other places, and then however I leave this function, whether I'm using a guard statement with an early exit, or I'm throwing an error, or I'm successfully completing the function and going all the way to the end, I can be sure that what's in this defer block will be called right at the end.
